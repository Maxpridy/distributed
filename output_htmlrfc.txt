RFC 2616  Hypertext Transfer Protocol  HTTP11
Docs txtpdf draftietfhttpv Diff1 Diff2 Errata
Obsoleted by 7230 7231 7232 7233 7234 7235
DRAFT STANDARD
Updated by 2817 5785 6266 6585 Errata Exist
Network Working Group
R Fielding
Request for Comments 2616
UC Irvine
Obsoletes 2068
J Gettys
Category Standards Track
CompaqW3C
J Mogul
Compaq
H Frystyk
W3CMIT
L Masinter
Xerox
P Leach
Microsoft
T BernersLee
W3CMIT
June 1999
Hypertext Transfer Protocol  HTTP11
Status of this Memo
This document specifies an Internet standards track protocol for the
Internet community and requests discussion and suggestions for
improvements
Please refer to the current edition of the Internet
Official Protocol Standards STD 1 for the standardization state
and status of this protocol
Distribution of this memo is unlimited
Copyright Notice
Copyright C The Internet Society 1999
All Rights Reserved
Abstract
The Hypertext Transfer Protocol HTTP is an applicationlevel
protocol for distributed collaborative hypermedia information
systems It is a generic stateless protocol which can be used for
many tasks beyond its use for hypertext such as name servers and
distributed object management systems through extension of its
request methods error codes and headers 47 A feature of HTTP is
the typing and negotiation of data representation allowing systems
to be built independently of the data being transferred
HTTP has been in use by the WorldWide Web global information
initiative since 1990 This specification defines the protocol
referred to as HTTP11 and is an update to RFC 2068 33
Fielding et al
Standards Track
Page 1
RFC 2616
HTTP11
June 1999
Table of Contents
1
Introduction 7
11
Purpose7
12
Requirements 8
13
Terminology 8
14
Overall Operation 12
2
Notational Conventions and Generic Grammar 14
21
Augmented BNF 14
22
Basic Rules 15
3
Protocol Parameters 17
31
HTTP Version 17
32
Uniform Resource Identifiers 18
321
General Syntax 19
322
http URL 19
323
URI Comparison 20
33
DateTime Formats 20
331
Full Date 20
332
Delta Seconds 21
34
Character Sets 21
341
Missing Charset 22
35
Content Codings 23
36
Transfer Codings 24
361
Chunked Transfer Coding 25
37
Media Types 26
371
Canonicalization and Text Defaults 27
372
Multipart Types 27
38
Product Tokens 28
39
Quality Values 29
310
Language Tags 29
311
Entity Tags 30
312
Range Units 30
4
HTTP Message 31
41
Message Types 31
42
Message Headers 31
43
Message Body 32
44
Message Length 33
45
General Header Fields 34
5
Request 35
51
RequestLine 35
511
Method 36
512
RequestURI 36
52
The Resource Identified by a Request 38
53
Request Header Fields 38
6
Response 39
61
StatusLine 39
611
Status Code and Reason Phrase 39
62
Response Header Fields 41
Fielding et al
Standards Track
Page 2
RFC 2616
HTTP11
June 1999
7
Entity 42
71
Entity Header Fields 42
72
Entity Body 43
721
Type 43
722
Entity Length 43
8
Connections 44
81
Persistent Connections 44
811
Purpose 44
812
Overall Operation 45
813
Proxy Servers 46
814
Practical Considerations 46
82
Message Transmission Requirements 47
821
Persistent Connections and Flow Control 47
822
Monitoring Connections for Error Status Messages 48
823
Use of the 100 Continue Status 48
824
Client Behavior if Server Prematurely Closes Connection 50
9
Method Definitions 51
91
Safe and Idempotent Methods 51
911
Safe Methods 51
912
Idempotent Methods 51
92
OPTIONS 52
93
GET 53
94
HEAD 54
95
POST 54
96
PUT 55
97
DELETE 56
98
TRACE 56
99
CONNECT 57
10
Status Code Definitions 57
101
Informational 1xx 57
1011
100 Continue 58
1012
101 Switching Protocols 58
102
Successful 2xx 58
1021
200 OK 58
1022
201 Created 59
1023
202 Accepted 59
1024
203 NonAuthoritative Information 59
1025
204 No Content 60
1026
205 Reset Content 60
1027
206 Partial Content 60
103
Redirection 3xx 61
1031
300 Multiple Choices 61
1032
301 Moved Permanently 62
1033
302 Found 62
1034
303 See Other 63
1035
304 Not Modified 63
1036
305 Use Proxy 64
1037
306 Unused 64
Fielding et al
Standards Track
Page 3
RFC 2616
HTTP11
June 1999
1038
307 Temporary Redirect 65
104
Client Error 4xx 65
1041
400 Bad Request 65
1042
401 Unauthorized 66
1043
402 Payment Required 66
1044
403 Forbidden 66
1045
404 Not Found 66
1046
405 Method Not Allowed 66
1047
406 Not Acceptable 67
1048
407 Proxy Authentication Required 67
1049
408 Request Timeout 67
10410
409 Conflict 67
10411
410 Gone 68
10412
411 Length Required 68
10413
412 Precondition Failed 68
10414
413 Request Entity Too Large 69
10415
414 RequestURI Too Long 69
10416
415 Unsupported Media Type 69
10417
416 Requested Range Not Satisfiable 69
10418
417 Expectation Failed 70
105
Server Error 5xx 70
1051
500 Internal Server Error 70
1052
501 Not Implemented 70
1053
502 Bad Gateway 70
1054
503 Service Unavailable 70
1055
504 Gateway Timeout 71
1056
505 HTTP Version Not Supported 71
11
Access Authentication 71
12
Content Negotiation 71
121
Serverdriven Negotiation 72
122
Agentdriven Negotiation 73
123
Transparent Negotiation 74
13
Caching in HTTP 74
1311
Cache Correctness 75
1312
Warnings 76
1313
Cachecontrol Mechanisms 77
1314
Explicit User Agent Warnings 78
1315
Exceptions to the Rules and Warnings 78
1316
Clientcontrolled Behavior 79
132
Expiration Model 79
1321
ServerSpecified Expiration 79
1322
Heuristic Expiration 80
1323
Age Calculations 80
1324
Expiration Calculations 83
1325
Disambiguating Expiration Values 84
1326
Disambiguating Multiple Responses 84
133
Validation Model 85
1331
LastModified Dates 86
Fielding et al
Standards Track
Page 4
RFC 2616
HTTP11
June 1999
1332
Entity Tag Cache Validators 86
1333
Weak and Strong Validators 86
1334
Rules for When to Use Entity Tags and LastModified Dates89
1335
Nonvalidating Conditionals 90
134
Response Cacheability 91
135
Constructing Responses From Caches 92
1351
Endtoend and Hopbyhop Headers 92
1352
Nonmodifiable Headers 92
1353
Combining Headers 94
1354
Combining Byte Ranges 95
136
Caching Negotiated Responses 95
137
Shared and NonShared Caches 96
138
Errors or Incomplete Response Cache Behavior 97
139
Side Effects of GET and HEAD 97
1310
Invalidation After Updates or Deletions 97
1311
WriteThrough Mandatory 98
1312
Cache Replacement 99
1313
History Lists 99
14
Header Field Definitions 100
141
Accept 100
142
AcceptCharset 102
143
AcceptEncoding 102
144
AcceptLanguage 104
145
AcceptRanges 105
146
Age 106
147
Allow 106
148
Authorization 107
149
CacheControl 108
1491
What is Cacheable 109
1492
What May be Stored by Caches 110
1493
Modifications of the Basic Expiration Mechanism 111
1494
Cache Revalidation and Reload Controls 113
1495
NoTransform Directive 115
1496
Cache Control Extensions 116
1410
Connection 117
1411
ContentEncoding 118
1412
ContentLanguage 118
1413
ContentLength 119
1414
ContentLocation 120
1415
ContentMD5 121
1416
ContentRange 122
1417
ContentType 124
1418
Date 124
14181
Clockless Origin Server Operation 125
1419
ETag 126
1420
Expect 126
1421
Expires 127
1422
From 128
Fielding et al
Standards Track
Page 5
RFC 2616
HTTP11
June 1999
1423
Host 128
1424
IfMatch 129
1425
IfModifiedSince 130
1426
IfNoneMatch 132
1427
IfRange 133
1428
IfUnmodifiedSince 134
1429
LastModified 134
1430
Location 135
1431
MaxForwards 136
1432
Pragma 136
1433
ProxyAuthenticate 137
1434
ProxyAuthorization 137
1435
Range 138
14351
Byte Ranges 138
14352
Range Retrieval Requests 139
1436
Referer 140
1437
RetryAfter 141
1438
Server 141
1439
TE 142
1440
Trailer 143
1441
TransferEncoding143
1442
Upgrade 144
1443
UserAgent 145
1444
Vary 145
1445
Via 146
1446
Warning 148
1447
WWWAuthenticate 150
15 Security Considerations 150
151
Personal Information151
1511
Abuse of Server Log Information 151
1512
Transfer of Sensitive Information 151
1513
Encoding Sensitive Information in URIs 152
1514
Privacy Issues Connected to Accept Headers 152
152
Attacks Based On File and Path Names 153
153
DNS Spoofing 154
154
Location Headers and Spoofing 154
155
ContentDisposition Issues 154
156
Authentication Credentials and Idle Clients 155
157
Proxies and Caching 155
1571
Denial of Service Attacks on Proxies156
16
Acknowledgments 156
17
References 158
18
Authors Addresses 162
19
Appendices 164
191
Internet Media Type messagehttp and applicationhttp 164
192
Internet Media Type multipartbyteranges 165
193
Tolerant Applications 166
194
Differences Between HTTP Entities and RFC 2045 Entities 167
Fielding et al
Standards Track
Page 6
RFC 2616
HTTP11
June 1999
1941
MIMEVersion 167
1942
Conversion to Canonical Form 167
1943
Conversion of Date Formats 168
1944
Introduction of ContentEncoding 168
1945
No ContentTransferEncoding 168
1946
Introduction of TransferEncoding 169
1947
MHTML and Line Length Limitations 169
195
Additional Features 169
1951
ContentDisposition 170
196
Compatibility with Previous Versions 170
1961
Changes from HTTP10 171
1962
Compatibility with HTTP10 Persistent Connections 172
1963
Changes from RFC 2068 172
20
Index 175
21
Full Copyright Statement 176
1 Introduction
11 Purpose
The Hypertext Transfer Protocol HTTP is an applicationlevel
protocol for distributed collaborative hypermedia information
systems HTTP has been in use by the WorldWide Web global
information initiative since 1990 The first version of HTTP
referred to as HTTP09 was a simple protocol for raw data transfer
across the Internet HTTP10 as defined by RFC 1945 6 improved
the protocol by allowing messages to be in the format of MIMElike
messages containing metainformation about the data transferred and
modifiers on the requestresponse semantics However HTTP10 does
not sufficiently take into consideration the effects of hierarchical
proxies caching the need for persistent connections or virtual
hosts In addition the proliferation of incompletelyimplemented
applications calling themselves HTTP10 has necessitated a
protocol version change in order for two communicating applications
to determine each others true capabilities
This specification defines the protocol referred to as HTTP11
This protocol includes more stringent requirements than HTTP10 in
order to ensure reliable implementation of its features
Practical information systems require more functionality than simple
retrieval including search frontend update and annotation HTTP
allows an openended set of methods and headers that indicate the
purpose of a request 47 It builds on the discipline of reference
provided by the Uniform Resource Identifier URI 3 as a location
URL 4 or name URN 20 for indicating the resource to which a
Fielding et al
Standards Track
Page 7
RFC 2616
HTTP11
June 1999
method is to be applied Messages are passed in a format similar to
that used by Internet mail 9 as defined by the Multipurpose
Internet Mail Extensions MIME 7
HTTP is also used as a generic protocol for communication between
user agents and proxiesgateways to other Internet systems including
those supported by the SMTP 16 NNTP 13 FTP 18 Gopher 2
and WAIS 10 protocols In this way HTTP allows basic hypermedia
access to resources available from diverse applications
12 Requirements
The key words MUST MUST NOT REQUIRED SHALL SHALL NOT
SHOULD SHOULD NOT RECOMMENDED MAY and OPTIONAL in this
document are to be interpreted as described in RFC 2119 34
An implementation is not compliant if it fails to satisfy one or more
of the MUST or REQUIRED level requirements for the protocols it
implements An implementation that satisfies all the MUST or REQUIRED
level and all the SHOULD level requirements for its protocols is said
to be unconditionally compliant one that satisfies all the MUST
level requirements but not all the SHOULD level requirements for its
protocols is said to be conditionally compliant
13 Terminology
This specification uses a number of terms to refer to the roles
played by participants in and objects of the HTTP communication
connection
A transport layer virtual circuit established between two programs
for the purpose of communication
message
The basic unit of HTTP communication consisting of a structured
sequence of octets matching the syntax defined in section 4 and
transmitted via the connection
request
An HTTP request message as defined in section 5
response
An HTTP response message as defined in section 6
Fielding et al
Standards Track
Page 8
RFC 2616
HTTP11
June 1999
resource
A network data object or service that can be identified by a URI
as defined in section 32 Resources may be available in multiple
representations eg multiple languages data formats size and
resolutions or vary in other ways
entity
The information transferred as the payload of a request or
response An entity consists of metainformation in the form of
entityheader fields and content in the form of an entitybody as
described in section 7
representation
An entity included with a response that is subject to content
negotiation as described in section 12 There may exist multiple
representations associated with a particular response status
content negotiation
The mechanism for selecting the appropriate representation when
servicing a request as described in section 12 The
representation of entities in any response can be negotiated
including error responses
variant
A resource may have one or more than one representations
associated with it at any given instant Each of these
representations is termed a varriant
Use of the term variant
does not necessarily imply that the resource is subject to content
negotiation
client
A program that establishes connections for the purpose of sending
requests
user agent
The client which initiates a request These are often browsers
editors spiders webtraversing robots or other end user tools
server
An application program that accepts connections in order to
service requests by sending back responses Any given program may
be capable of being both a client and a server our use of these
terms refers only to the role being performed by the program for a
particular connection rather than to the programs capabilities
in general Likewise any server may act as an origin server
proxy gateway or tunnel switching behavior based on the nature
of each request
Fielding et al
Standards Track
Page 9
RFC 2616
HTTP11
June 1999
origin server
The server on which a given resource resides or is to be created
proxy
An intermediary program which acts as both a server and a client
for the purpose of making requests on behalf of other clients
Requests are serviced internally or by passing them on with
possible translation to other servers A proxy MUST implement
both the client and server requirements of this specification A
transparent proxy is a proxy that does not modify the request or
response beyond what is required for proxy authentication and
identification A nontransparent proxy is a proxy that modifies
the request or response in order to provide some added service to
the user agent such as group annotation services media type
transformation protocol reduction or anonymity filtering Except
where either transparent or nontransparent behavior is explicitly
stated the HTTP proxy requirements apply to both types of
proxies
gateway
A server which acts as an intermediary for some other server
Unlike a proxy a gateway receives requests as if it were the
origin server for the requested resource the requesting client
may not be aware that it is communicating with a gateway
tunnel
An intermediary program which is acting as a blind relay between
two connections Once active a tunnel is not considered a party
to the HTTP communication though the tunnel may have been
initiated by an HTTP request The tunnel ceases to exist when both
ends of the relayed connections are closed
cache
A programs local store of response messages and the subsystem
that controls its message storage retrieval and deletion A
cache stores cacheable responses in order to reduce the response
time and network bandwidth consumption on future equivalent
requests Any client or server may include a cache though a cache
cannot be used by a server that is acting as a tunnel
cacheable
A response is cacheable if a cache is allowed to store a copy of
the response message for use in answering subsequent requests The
rules for determining the cacheability of HTTP responses are
defined in section 13 Even if a resource is cacheable there may
be additional constraints on whether a cache can use the cached
copy for a particular request
Fielding et al
Standards Track
Page 10
RFC 2616
HTTP11
June 1999
firsthand
A response is firsthand if it comes directly and without
unnecessary delay from the origin server perhaps via one or more
proxies A response is also firsthand if its validity has just
been checked directly with the origin server
explicit expiration time
The time at which the origin server intends that an entity should
no longer be returned by a cache without further validation
heuristic expiration time
An expiration time assigned by a cache when no explicit expiration
time is available
age
The age of a response is the time since it was sent by or
successfully validated with the origin server
freshness lifetime
The length of time between the generation of a response and its
expiration time
fresh
A response is fresh if its age has not yet exceeded its freshness
lifetime
stale
A response is stale if its age has passed its freshness lifetime
semantically transparent
A cache behaves in a semantically transparent manner with
respect to a particular response when its use affects neither the
requesting client nor the origin server except to improve
performance When a cache is semantically transparent the client
receives exactly the same response except for hopbyhop headers
that it would have received had its request been handled directly
by the origin server
validator
A protocol element eg an entity tag or a LastModified time
that is used to find out whether a cache entry is an equivalent
copy of an entity
upstreamdownstream
Upstream and downstream describe the flow of a message all
messages flow from upstream to downstream
Fielding et al
Standards Track
Page 11
RFC 2616
HTTP11
June 1999
inboundoutbound
Inbound and outbound refer to the request and response paths for
messages inbound means traveling toward the origin server
and outbound means traveling toward the user agent
14 Overall Operation
The HTTP protocol is a requestresponse protocol A client sends a
request to the server in the form of a request method URI and
protocol version followed by a MIMElike message containing request
modifiers client information and possible body content over a
connection with a server The server responds with a status line
including the messages protocol version and a success or error code
followed by a MIMElike message containing server information entity
metainformation and possible entitybody content The relationship
between HTTP and MIME is described in appendix 194
Most HTTP communication is initiated by a user agent and consists of
a request to be applied to a resource on some origin server In the
simplest case this may be accomplished via a single connection v
between the user agent UA and the origin server O
request chain
UA v O
 response chain
A more complicated situation occurs when one or more intermediaries
are present in the requestresponse chain There are three common
forms of intermediary proxy gateway and tunnel A proxy is a
forwarding agent receiving requests for a URI in its absolute form
rewriting all or part of the message and forwarding the reformatted
request toward the server identified by the URI A gateway is a
receiving agent acting as a layer above some other servers and if
necessary translating the requests to the underlying servers
protocol A tunnel acts as a relay point between two connections
without changing the messages tunnels are used when the
communication needs to pass through an intermediary such as a
firewall even when the intermediary cannot understand the contents
of the messages
request chain
UA v A v B v C v O
 response chain
The figure above shows three intermediaries A B and C between the
user agent and origin server A request or response message that
travels the whole chain will pass through four separate connections
This distinction is important because some HTTP communication options
Fielding et al
Standards Track
Page 12
RFC 2616
HTTP11
June 1999
may apply only to the connection with the nearest nontunnel
neighbor only to the endpoints of the chain or to all connections
along the chain Although the diagram is linear each participant may
be engaged in multiple simultaneous communications For example B
may be receiving requests from many clients other than A andor
forwarding requests to servers other than C at the same time that it
is handling As request
Any party to the communication which is not acting as a tunnel may
employ an internal cache for handling requests The effect of a cache
is that the requestresponse chain is shortened if one of the
participants along the chain has a cached response applicable to that
request The following illustrates the resulting chain if B has a
cached copy of an earlier response from O via C for a request which
has not been cached by UA or A
request chain
UA v A v B       C       O
 response chain
Not all responses are usefully cacheable and some requests may
contain modifiers which place special requirements on cache behavior
HTTP requirements for cache behavior and cacheable responses are
defined in section 13
In fact there are a wide variety of architectures and configurations
of caches and proxies currently being experimented with or deployed
across the World Wide Web These systems include national hierarchies
of proxy caches to save transoceanic bandwidth systems that
broadcast or multicast cache entries organizations that distribute
subsets of cached data via CDROM and so on HTTP systems are used
in corporate intranets over highbandwidth links and for access via
PDAs with lowpower radio links and intermittent connectivity The
goal of HTTP11 is to support the wide diversity of configurations
already deployed while introducing protocol constructs that meet the
needs of those who build web applications that require high
reliability and failing that at least reliable indications of
failure
HTTP communication usually takes place over TCPIP connections The
default port is TCP 80 19 but other ports can be used This does
not preclude HTTP from being implemented on top of any other protocol
on the Internet or on other networks HTTP only presumes a reliable
transport any protocol that provides such guarantees can be used
the mapping of the HTTP11 request and response structures onto the
transport data units of the protocol in question is outside the scope
of this specification
Fielding et al
Standards Track
Page 13
RFC 2616
HTTP11
June 1999
In HTTP10 most implementations used a new connection for each
requestresponse exchange In HTTP11 a connection may be used for
one or more requestresponse exchanges although connections may be
closed for a variety of reasons see section 81
2 Notational Conventions and Generic Grammar
21 Augmented BNF
All of the mechanisms specified in this document are described in
both prose and an augmented BackusNaur Form BNF similar to that
used by RFC 822 9 Implementors will need to be familiar with the
notation in order to understand this specification The augmented BNF
includes the following constructs
name  definition
The name of a rule is simply the name itself without any
enclosing  and  and is separated from its definition by the
equal  character White space is only significant in that
indentation of continuation lines is used to indicate a rule
definition that spans more than one line Certain basic rules are
in uppercase such as SP LWS HT CRLF DIGIT ALPHA etc Angle
brackets are used within definitions whenever their presence will
facilitate discerning the use of rule names
literal
Quotation marks surround literal text Unless stated otherwise
the text is caseinsensitive
rule1  rule2
Elements separated by a bar  are alternatives eg yes
no will accept yes or no
rule1 rule2
Elements enclosed in parentheses are treated as a single element
Thus elem foo  bar elem allows the token sequences elem
foo elem and elem bar elem
rule
The character  preceding an element indicates repetition The
full form is nmelement indicating at least n and at most
m occurrences of element Default values are 0 and infinity so
that element allows any number including zero 1element
requires at least one and 12element allows one or two
rule
Square brackets enclose optional elements foo bar is
equivalent to 1foo bar
Fielding et al
Standards Track
Page 14
RFC 2616
HTTP11
June 1999
N rule
Specific repetition nelement is equivalent to
nnelement that is exactly n occurrences of element
Thus 2DIGIT is a 2digit number and 3ALPHA is a string of three
alphabetic characters
rule
A construct  is defined similar to  for defining lists of
elements The full form is nmelement indicating at least
n and at most m elements each separated by one or more commas
 and OPTIONAL linear white space LWS This makes the usual
form of lists very easy a rule such as
 LWS element  LWS  LWS element
can be shown as
1element
Wherever this construct is used null elements are allowed but do
not contribute to the count of elements present That is
element  element  is permitted but counts as only two
elements Therefore where at least one element is required at
least one nonnull element MUST be present Default values are 0
and infinity so that element allows any number including zero
1element requires at least one and 12element allows one or
two
 comment
A semicolon set off some distance to the right of rule text
starts a comment that continues to the end of line This is a
simple way of including useful notes in parallel with the
specifications
implied LWS
The grammar described by this specification is wordbased Except
where noted otherwise linear white space LWS can be included
between any two adjacent words token or quotedstring and
between adjacent words and separators without changing the
interpretation of a field At least one delimiter LWS andor
separators MUST exist between any two tokens for the definition
of token below since they would otherwise be interpreted as a
single token
22 Basic Rules
The following rules are used throughout this specification to
describe basic parsing constructs The USASCII coded character set
is defined by ANSI X341986 21
Fielding et al
Standards Track
Page 15
RFC 2616
HTTP11
June 1999
OCTET
 any 8bit sequence of data
CHAR
 any USASCII character octets 0  127
UPALPHA
 any USASCII uppercase letter AZ
LOALPHA
 any USASCII lowercase letter az
ALPHA
 UPALPHA  LOALPHA
DIGIT
 any USASCII digit 09
CTL
 any USASCII control character
octets 0  31 and DEL 127
CR
 USASCII CR carriage return 13
LF
 USASCII LF linefeed 10
SP
 USASCII SP space 32
HT
 USASCII HT horizontaltab 9

 USASCII doublequote mark 34
HTTP11 defines the sequence CR LF as the endofline marker for all
protocol elements except the entitybody see appendix 193 for
tolerant applications The endofline marker within an entitybody
is defined by its associated media type as described in section 37
CRLF
 CR LF
HTTP11 header field values can be folded onto multiple lines if the
continuation line begins with a space or horizontal tab All linear
white space including folding has the same semantics as SP A
recipient MAY replace any linear white space with a single SP before
interpreting the field value or forwarding the message downstream
LWS
 CRLF 1 SP  HT
The TEXT rule is only used for descriptive field contents and values
that are not intended to be interpreted by the message parser Words
of TEXT MAY contain characters from character sets other than ISO
88591 22 only when encoded according to the rules of RFC 2047
14
TEXT
 any OCTET except CTLs
but including LWS
A CRLF is allowed in the definition of TEXT only as part of a header
field continuation It is expected that the folding LWS will be
replaced with a single SP before interpretation of the TEXT value
Hexadecimal numeric characters are used in several protocol elements
HEX
 A  B  C  D  E  F
 a  b  c  d  e  f  DIGIT
Fielding et al
Standards Track
Page 16
RFC 2616
HTTP11
June 1999
Many HTTP11 header field values consist of words separated by LWS
or special characters These special characters MUST be in a quoted
string to be used within a parameter value as defined in section
36
token
 1any CHAR except CTLs or separators
separators



     SP  HT
Comments can be included in some HTTP header fields by surrounding
the comment text with parentheses Comments are only allowed in
fields containing comment as part of their field value definition
In all other fields parentheses are considered part of the field
value
comment
   ctext  quotedpair  comment
ctext
 any TEXT excluding  and
A string of text is parsed as a single word if it is quoted using
doublequote marks
quotedstring
   qdtext  quotedpair
qdtext
 any TEXT except
The backslash character  MAY be used as a singlecharacter
quoting mechanism only within quotedstring and comment constructs
quotedpair
  CHAR
3 Protocol Parameters
31 HTTP Version
HTTP uses a majorminor numbering scheme to indicate versions
of the protocol The protocol versioning policy is intended to allow
the sender to indicate the format of a message and its capacity for
understanding further HTTP communication rather than the features
obtained via that communication No change is made to the version
number for the addition of message components which do not affect
communication behavior or which only add to extensible field values
The minor number is incremented when the changes made to the
protocol add features which do not change the general message parsing
algorithm but which may add to the message semantics and imply
additional capabilities of the sender The major number is
incremented when the format of a message within the protocol is
changed See RFC 2145 36 for a fuller explanation
Fielding et al
Standards Track
Page 17
RFC 2616
HTTP11
June 1999
The version of an HTTP message is indicated by an HTTPVersion field
in the first line of the message
HTTPVersion
 HTTP  1DIGIT  1DIGIT
Note that the major and minor numbers MUST be treated as separate
integers and that each MAY be incremented higher than a single digit
Thus HTTP24 is a lower version than HTTP213 which in turn is
lower than HTTP123 Leading zeros MUST be ignored by recipients and
MUST NOT be sent
An application that sends a request or response message that includes
HTTPVersion of HTTP11 MUST be at least conditionally compliant
with this specification Applications that are at least conditionally
compliant with this specification SHOULD use an HTTPVersion of
HTTP11 in their messages and MUST do so for any message that is
not compatible with HTTP10 For more details on when to send
specific HTTPVersion values see RFC 2145 36
The HTTP version of an application is the highest HTTP version for
which the application is at least conditionally compliant
Proxy and gateway applications need to be careful when forwarding
messages in protocol versions different from that of the application
Since the protocol version indicates the protocol capability of the
sender a proxygateway MUST NOT send a message with a version
indicator which is greater than its actual version If a higher
version request is received the proxygateway MUST either downgrade
the request version or respond with an error or switch to tunnel
behavior
Due to interoperability problems with HTTP10 proxies discovered
since the publication of RFC 206833 caching proxies MUST gateways
MAY and tunnels MUST NOT upgrade the request to the highest version
they support The proxygateways response to that request MUST be in
the same major version as the request
Note Converting between versions of HTTP may involve modification
of header fields required or forbidden by the versions involved
32 Uniform Resource Identifiers
URIs have been known by many names WWW addresses Universal Document
Identifiers Universal Resource Identifiers 3 and finally the
combination of Uniform Resource Locators URL 4 and Names URN
20 As far as HTTP is concerned Uniform Resource Identifiers are
simply formatted strings which identifyvia name location or any
other characteristica resource
Fielding et al
Standards Track
Page 18
RFC 2616
HTTP11
June 1999
321 General Syntax
URIs in HTTP can be represented in absolute form or relative to some
known base URI 11 depending upon the context of their use The two
forms are differentiated by the fact that absolute URIs always begin
with a scheme name followed by a colon For definitive information on
URL syntax and semantics see Uniform Resource Identifiers URI
Generic Syntax and Semantics RFC 2396 42 which replaces RFCs
1738 4 and RFC 1808 11 This specification adopts the
definitions of URIreference absoluteURI relativeURI port
hostabs_path rel_path and authority from that
specification
The HTTP protocol does not place any a priori limit on the length of
a URI Servers MUST be able to handle the URI of any resource they
serve and SHOULD be able to handle URIs of unbounded length if they
provide GETbased forms that could generate such URIs A server
SHOULD return 414 RequestURI Too Long status if a URI is longer
than the server can handle see section 10415
Note Servers ought to be cautious about depending on URI lengths
above 255 bytes because some older client or proxy
implementations might not properly support these lengths
322 http URL
The http scheme is used to locate network resources via the HTTP
protocol This section defines the schemespecific syntax and
semantics for http URLs
http_URL  http  host   port   abs_path   query
If the port is empty or not given port 80 is assumed The semantics
are that the identified resource is located at the server listening
for TCP connections on that port of that host and the RequestURI
for the resource is abs_path section 512 The use of IP addresses
in URLs SHOULD be avoided whenever possible see RFC 1900 24 If
the abs_path is not present in the URL it MUST be given as  when
used as a RequestURI for a resource section 512 If a proxy
receives a host name which is not a fully qualified domain name it
MAY add its domain to the host name it received If a proxy receives
a fully qualified domain name the proxy MUST NOT change the host
name
Fielding et al
Standards Track
Page 19
RFC 2616
HTTP11
June 1999
323 URI Comparison
When comparing two URIs to decide if they match or not a client
SHOULD use a casesensitive octetbyoctet comparison of the entire
URIs with these exceptions
 A port that is empty or not given is equivalent to the default
port for that URIreference
 Comparisons of host names MUST be caseinsensitive
 Comparisons of scheme names MUST be caseinsensitive
 An empty abs_path is equivalent to an abs_path of
Characters other than those in the reserved and unsafe sets see
RFC 2396 42 are equivalent to their % HEX HEX encoding
For example the following three URIs are equivalent
httpabccom80~smithhomehtml
httpABCcom%7Esmithhomehtml
httpABCcom%7esmithhomehtml
33 DateTime Formats
331 Full Date
HTTP applications have historically allowed three different formats
for the representation of datetime stamps
Sun 06 Nov 1994 084937 GMT
 RFC 822 updated by RFC 1123
Sunday 06Nov94 084937 GMT  RFC 850 obsoleted by RFC 1036
Sun Nov
6 084937 1994
 ANSI Cs asctime format
The first format is preferred as an Internet standard and represents
a fixedlength subset of that defined by RFC 1123 8 an update to
RFC 822 9 The second format is in common use but is based on the
obsolete RFC 850 12 date format and lacks a fourdigit year
HTTP11 clients and servers that parse the date value MUST accept
all three formats for compatibility with HTTP10 though they MUST
only generate the RFC 1123 format for representing HTTPdate values
in header fields See section 193 for further information
Note Recipients of date values are encouraged to be robust in
accepting date values that may have been sent by nonHTTP
applications as is sometimes the case when retrieving or posting
messages via proxiesgateways to SMTP or NNTP
Fielding et al
Standards Track
Page 20
RFC 2616
HTTP11
June 1999
All HTTP datetime stamps MUST be represented in Greenwich Mean Time
GMT without exception For the purposes of HTTP GMT is exactly
equal to UTC Coordinated Universal Time This is indicated in the
first two formats by the inclusion of GMT as the threeletter
abbreviation for time zone and MUST be assumed when reading the
asctime format HTTPdate is case sensitive and MUST NOT include
additional LWS beyond that specifically included as SP in the
grammar
HTTPdate
 rfc1123date  rfc850date  asctimedate
rfc1123date  wkday  SP date1 SP time SP GMT
rfc850date
 weekday  SP date2 SP time SP GMT
asctimedate  wkday SP date3 SP time SP 4DIGIT
date1
 2DIGIT SP month SP 4DIGIT
 day month year eg 02 Jun 1982
date2
 2DIGIT  month  2DIGIT
 daymonthyear eg 02Jun82
date3
 month SP  2DIGIT   SP 1DIGIT
 month day eg Jun
2
time
 2DIGIT  2DIGIT  2DIGIT
 000000  235959
wkday
 Mon  Tue  Wed
 Thu  Fri  Sat  Sun
weekday
 Monday  Tuesday  Wednesday
 Thursday  Friday  Saturday  Sunday
month
 Jan  Feb  Mar  Apr
 May  Jun  Jul  Aug
 Sep  Oct  Nov  Dec
Note HTTP requirements for the datetime stamp format apply only
to their usage within the protocol stream Clients and servers are
not required to use these formats for user presentation request
logging etc
332 Delta Seconds
Some HTTP header fields allow a time value to be specified as an
integer number of seconds represented in decimal after the time
that the message was received
deltaseconds
 1DIGIT
34 Character Sets
HTTP uses the same definition of the term character set as that
described for MIME
Fielding et al
Standards Track
Page 21
RFC 2616
HTTP11
June 1999
The term character set is used in this document to refer to a
method used with one or more tables to convert a sequence of octets
into a sequence of characters Note that unconditional conversion in
the other direction is not required in that not all characters may
be available in a given character set and a character set may provide
more than one sequence of octets to represent a particular character
This definition is intended to allow various kinds of character
encoding from simple singletable mappings such as USASCII to
complex table switching methods such as those that use ISO2022s
techniques However the definition associated with a MIME character
set name MUST fully specify the mapping to be performed from octets
to characters In particular use of external profiling information
to determine the exact mapping is not permitted
Note This use of the term character set is more commonly
referred to as a character encoding However since HTTP and
MIME share the same registry it is important that the terminology
also be shared
HTTP character sets are identified by caseinsensitive tokens The
complete set of tokens is defined by the IANA Character Set registry
19
charset  token
Although HTTP allows an arbitrary token to be used as a charset
value any token that has a predefined value within the IANA
Character Set registry 19 MUST represent the character set defined
by that registry Applications SHOULD limit their use of character
sets to those defined by the IANA registry
Implementors should be aware of IETF character set requirements 38
41
341 Missing Charset
Some HTTP10 software has interpreted a ContentType header without
charset parameter incorrectly to mean recipient should guess
Senders wishing to defeat this behavior MAY include a charset
parameter even when the charset is ISO88591 and SHOULD do so when
it is known that it will not confuse the recipient
Unfortunately some older HTTP10 clients did not deal properly with
an explicit charset parameter HTTP11 recipients MUST respect the
charset label provided by the sender and those user agents that have
a provision to guess a charset MUST use the charset from the
Fielding et al
Standards Track
Page 22
RFC 2616
HTTP11
June 1999
contenttype field if they support that charset rather than the
recipients preference when initially displaying a document See
section 371
35 Content Codings
Content coding values indicate an encoding transformation that has
been or can be applied to an entity Content codings are primarily
used to allow a document to be compressed or otherwise usefully
transformed without losing the identity of its underlying media type
and without loss of information Frequently the entity is stored in
coded form transmitted directly and only decoded by the recipient
contentcoding
 token
All contentcoding values are caseinsensitive HTTP11 uses
contentcoding values in the AcceptEncoding section 143 and
ContentEncoding section 1411 header fields Although the value
describes the contentcoding what is more important is that it
indicates what decoding mechanism will be required to remove the
encoding
The Internet Assigned Numbers Authority IANA acts as a registry for
contentcoding value tokens Initially the registry contains the
following tokens
gzip An encoding format produced by the file compression program
gzip GNU zip as described in RFC 1952 25 This format is a
LempelZiv coding LZ77 with a 32 bit CRC
compress
The encoding format produced by the common UNIX file compression
program compress This format is an adaptive LempelZivWelch
coding LZW
Use of program names for the identification of encoding formats
is not desirable and is discouraged for future encodings Their
use here is representative of historical practice not good
design For compatibility with previous implementations of HTTP
applications SHOULD consider xgzip and xcompress to be
equivalent to gzip and compress respectively
deflate
The zlib format defined in RFC 1950 31 in combination with
the deflate compression mechanism described in RFC 1951 29
Fielding et al
Standards Track
Page 23
RFC 2616
HTTP11
June 1999
identity
The default identity encoding the use of no transformation
whatsoever This contentcoding is used only in the Accept
Encoding header and SHOULD NOT be used in the ContentEncoding
header
New contentcoding value tokens SHOULD be registered to allow
interoperability between clients and servers specifications of the
content coding algorithms needed to implement a new value SHOULD be
publicly available and adequate for independent implementation and
conform to the purpose of content coding defined in this section
36 Transfer Codings
Transfercoding values are used to indicate an encoding
transformation that has been can be or may need to be applied to an
entitybody in order to ensure safe transport through the network
This differs from a content coding in that the transfercoding is a
property of the message not of the original entity
transfercoding
 chunked  transferextension
transferextension
 token   parameter
Parameters are in
the form of attributevalue pairs
parameter
 attribute  value
attribute
 token
value
 token  quotedstring
All transfercoding values are caseinsensitive HTTP11 uses
transfercoding values in the TE header field section 1439 and in
the TransferEncoding header field section 1441
Whenever a transfercoding is applied to a messagebody the set of
transfercodings MUST include chunked unless the message is
terminated by closing the connection When the chunked transfer
coding is used it MUST be the last transfercoding applied to the
messagebody The chunked transfercoding MUST NOT be applied more
than once to a messagebody These rules allow the recipient to
determine the transferlength of the message section 44
Transfercodings are analogous to the ContentTransferEncoding
values of MIME 7 which were designed to enable safe transport of
binary data over a 7bit transport service However safe transport
has a different focus for an 8bitclean transfer protocol In HTTP
the only unsafe characteristic of messagebodies is the difficulty in
determining the exact body length section 722 or the desire to
encrypt data over a shared transport
Fielding et al
Standards Track
Page 24
RFC 2616
HTTP11
June 1999
The Internet Assigned Numbers Authority IANA acts as a registry for
transfercoding value tokens Initially the registry contains the
following tokens chunked section 361 identity section
362 gzip section 35 compress section 35 and deflate
section 35
New transfercoding value tokens SHOULD be registered in the same way
as new contentcoding value tokens section 35
A server which receives an entitybody with a transfercoding it does
not understand SHOULD return 501 Unimplemented and close the
connection A server MUST NOT send transfercodings to an HTTP10
client
361 Chunked Transfer Coding
The chunked encoding modifies the body of a message in order to
transfer it as a series of chunks each with its own size indicator
followed by an OPTIONAL trailer containing entityheader fields This
allows dynamically produced content to be transferred along with the
information necessary for the recipient to verify that it has
received the full message
ChunkedBody
 chunk
lastchunk
trailer
CRLF
chunk
 chunksize  chunkextension  CRLF
chunkdata CRLF
chunksize
 1HEX
lastchunk
 10  chunkextension  CRLF
chunkextension   chunkextname   chunkextval
chunkextname  token
chunkextval
 token  quotedstring
chunkdata
 chunksizeOCTET
trailer
 entityheader CRLF
The chunksize field is a string of hex digits indicating the size of
the chunk The chunked encoding is ended by any chunk whose size is
zero followed by the trailer which is terminated by an empty line
The trailer allows the sender to include additional HTTP header
fields at the end of the message The Trailer header field can be
used to indicate which header fields are included in a trailer see
section 1440
Fielding et al
Standards Track
Page 25
RFC 2616
HTTP11
June 1999
A server using chunked transfercoding in a response MUST NOT use the
trailer for any header fields unless at least one of the following is
true
athe request included a TE header field that indicates trailers is
acceptable in the transfercoding of the
response as described in
section 1439 or
bthe server is the origin server for the response the trailer
fields consist entirely of optional metadata and the recipient
could use the message in a manner acceptable to the origin server
without receiving this metadata
In other words the origin server
is willing to accept the possibility that the trailer fields might
be silently discarded along the path to the client
This requirement prevents an interoperability failure when the
message is being received by an HTTP11 or later proxy and
forwarded to an HTTP10 recipient It avoids a situation where
compliance with the protocol would have necessitated a possibly
infinite buffer on the proxy
An example process for decoding a ChunkedBody is presented in
appendix 1946
All HTTP11 applications MUST be able to receive and decode the
chunked transfercoding and MUST ignore chunkextension extensions
they do not understand
37 Media Types
HTTP uses Internet Media Types 17 in the ContentType section
1417 and Accept section 141 header fields in order to provide
open and extensible data typing and type negotiation
mediatype
 type  subtype   parameter
type
 token
subtype
 token
Parameters MAY follow the typesubtype in the form of attributevalue
pairs as defined in section 36
The type subtype and parameter attribute names are case
insensitive Parameter values might or might not be casesensitive
depending on the semantics of the parameter name Linear white space
LWS MUST NOT be used between the type and subtype nor between an
attribute and its value The presence or absence of a parameter might
be significant to the processing of a mediatype depending on its
definition within the media type registry
Fielding et al
Standards Track
Page 26
RFC 2616
HTTP11
June 1999
Note that some older HTTP applications do not recognize media type
parameters When sending data to older HTTP applications
implementations SHOULD only use media type parameters when they are
required by that typesubtype definition
Mediatype values are registered with the Internet Assigned Number
Authority IANA 19 The media type registration process is
outlined in RFC 1590 17 Use of nonregistered media types is
discouraged
371 Canonicalization and Text Defaults
Internet media types are registered with a canonical form An
entitybody transferred via HTTP messages MUST be represented in the
appropriate canonical form prior to its transmission except for
text types as defined in the next paragraph
When in canonical form media subtypes of the text type use CRLF as
the text line break HTTP relaxes this requirement and allows the
transport of text media with plain CR or LF alone representing a line
break when it is done consistently for an entire entitybody HTTP
applications MUST accept CRLF bare CR and bare LF as being
representative of a line break in text media received via HTTP In
addition if the text is represented in a character set that does not
use octets 13 and 10 for CR and LF respectively as is the case for
some multibyte character sets HTTP allows the use of whatever octet
sequences are defined by that character set to represent the
equivalent of CR and LF for line breaks This flexibility regarding
line breaks applies only to text media in the entitybody a bare CR
or LF MUST NOT be substituted for CRLF within any of the HTTP control
structures such as header fields and multipart boundaries
If an entitybody is encoded with a contentcoding the underlying
data MUST be in a form defined above prior to being encoded
The charset parameter is used with some media types to define the
character set section 34 of the data When no explicit charset
parameter is provided by the sender media subtypes of the text
type are defined to have a default charset value of ISO88591 when
received via HTTP Data in character sets other than ISO88591 or
its subsets MUST be labeled with an appropriate charset value See
section 341 for compatibility problems
372 Multipart Types
MIME provides for a number of multipart types  encapsulations of
one or more entities within a single messagebody All multipart
types share a common syntax as defined in section 511 of RFC 2046
Fielding et al
Standards Track
Page 27
RFC 2616
HTTP11
June 1999
40 and MUST include a boundary parameter as part of the media type
value The message body is itself a protocol element and MUST
therefore use only CRLF to represent line breaks between bodyparts
Unlike in RFC 2046 the epilogue of any multipart message MUST be
empty HTTP applications MUST NOT transmit the epilogue even if the
original multipart contains an epilogue These restrictions exist in
order to preserve the selfdelimiting nature of a multipart message
body wherein the end of the messagebody is indicated by the
ending multipart boundary
In general HTTP treats a multipart messagebody no differently than
any other media type strictly as payload The one exception is the
multipartbyteranges type appendix 192 when it appears in a 206
Partial Content response which will be interpreted by some HTTP
caching mechanisms as described in sections 1354 and 1416 In all
other cases an HTTP user agent SHOULD follow the same or similar
behavior as a MIME user agent would upon receipt of a multipart type
The MIME header fields within each bodypart of a multipart message
body do not have any significance to HTTP beyond that defined by
their MIME semantics
In general an HTTP user agent SHOULD follow the same or similar
behavior as a MIME user agent would upon receipt of a multipart type
If an application receives an unrecognized multipart subtype the
application MUST treat it as being equivalent to multipartmixed
Note The multipartformdata type has been specifically defined
for carrying form data suitable for processing via the POST
request method as described in RFC 1867 15
38 Product Tokens
Product tokens are used to allow communicating applications to
identify themselves by software name and version Most fields using
product tokens also allow subproducts which form a significant part
of the application to be listed separated by white space By
convention the products are listed in order of their significance
for identifying the application
product
 token  productversion
productversion  token
Examples
UserAgent CERNLineMode215 libwww217b3
Server Apache084
Fielding et al
Standards Track
Page 28
RFC 2616
HTTP11
June 1999
Product tokens SHOULD be short and to the point They MUST NOT be
used for advertising or other nonessential information Although any
token character MAY appear in a productversion this token SHOULD
only be used for a version identifier ie successive versions of
the same product SHOULD only differ in the productversion portion of
the product value
39 Quality Values
HTTP content negotiation section 12 uses short floating point
numbers to indicate the relative importance weight of various
negotiable parameters
A weight is normalized to a real number in
the range 0 through 1 where 0 is the minimum and 1 the maximum
value If a parameter has a quality value of 0 then content with
this parameter is not acceptable for the client HTTP11
applications MUST NOT generate more than three digits after the
decimal point User configuration of these values SHOULD also be
limited in this fashion
qvalue
  0   03DIGIT
  1   030
Quality values is a misnomer since these values merely represent
relative degradation in desired quality
310 Language Tags
A language tag identifies a natural language spoken written or
otherwise conveyed by human beings for communication of information
to other human beings Computer languages are explicitly excluded
HTTP uses language tags within the AcceptLanguage and Content
Language fields
The syntax and registry of HTTP language tags is the same as that
defined by RFC 1766 1 In summary a language tag is composed of 1
or more parts A primary language tag and a possibly empty series of
subtags
languagetag
 primarytag   subtag
primarytag
 18ALPHA
subtag
 18ALPHA
White space is not allowed within the tag and all tags are case
insensitive The name space of language tags is administered by the
IANA Example tags include
en enUS encockney icherokee xpiglatin
Fielding et al
Standards Track
Page 29
RFC 2616
HTTP11
June 1999
where any twoletter primarytag is an ISO639 language abbreviation
and any twoletter initial subtag is an ISO3166 country code The
last three tags above are not registered tags all but the last are
examples of tags which could be registered in future
311 Entity Tags
Entity tags are used for comparing two or more entities from the same
requested resource HTTP11 uses entity tags in the ETag section
1419 IfMatch section 1424 IfNoneMatch section 1426 and
IfRange section 1427 header fields The definition of how they
are used and compared as cache validators is in section 1333 An
entity tag consists of an opaque quoted string possibly prefixed by
a weakness indicator
entitytag   weak  opaquetag
weak
 W
opaquetag  quotedstring
A strong entity tag MAY be shared by two entities of a resource
only if they are equivalent by octet equality
A weak entity tag indicated by the W prefix MAY be shared by
two entities of a resource only if the entities are equivalent and
could be substituted for each other with no significant change in
semantics A weak entity tag can only be used for weak comparison
An entity tag MUST be unique across all versions of all entities
associated with a particular resource A given entity tag value MAY
be used for entities obtained by requests on different URIs The use
of the same entity tag value in conjunction with entities obtained by
requests on different URIs does not imply the equivalence of those
entities
312 Range Units
HTTP11 allows a client to request that only part a range of the
response entity be included within the response HTTP11 uses range
units in the Range section 1435 and ContentRange section 1416
header fields An entity can be broken down into subranges according
to various structural units
rangeunit
 bytesunit  otherrangeunit
bytesunit
 bytes
otherrangeunit  token
The only range unit defined by HTTP11 is bytes HTTP11
implementations MAY ignore ranges specified using other units
Fielding et al
Standards Track
Page 30
RFC 2616
HTTP11
June 1999
HTTP11 has been designed to allow implementations of applications
that do not depend on knowledge of ranges
4 HTTP Message
41 Message Types
HTTP messages consist of requests from client to server and responses
from server to client
HTTPmessage
 Request  Response
 HTTP11 messages
Request section 5 and Response section 6 messages use the generic
message format of RFC 822 9 for transferring entities the payload
of the message Both types of message consist of a startline zero
or more header fields also known as headers an empty line ie
a line with nothing preceding the CRLF indicating the end of the
header fields and possibly a messagebody
genericmessage  startline
messageheader CRLF
CRLF
 messagebody
startline
 RequestLine  StatusLine
In the interest of robustness servers SHOULD ignore any empty
lines received where a RequestLine is expected In other words if
the server is reading the protocol stream at the beginning of a
message and receives a CRLF first it should ignore the CRLF
Certain buggy HTTP10 client implementations generate extra CRLFs
after a POST request To restate what is explicitly forbidden by the
BNF an HTTP11 client MUST NOT preface or follow a request with an
extra CRLF
42 Message Headers
HTTP header fields which include generalheader section 45
requestheader section 53 responseheader section 62 and
entityheader section 71 fields follow the same generic format as
that given in Section 31 of RFC 822 9 Each header field consists
of a name followed by a colon  and the field value Field names
are caseinsensitive The field value MAY be preceded by any amount
of LWS though a single SP is preferred Header fields can be
extended over multiple lines by preceding each extra line with at
least one SP or HT Applications ought to follow common form where
one is known or indicated when generating HTTP constructs since
there might exist some implementations that fail to accept anything
Fielding et al
Standards Track
Page 31
RFC 2616
HTTP11
June 1999
beyond the common forms
messageheader  fieldname   fieldvalue
fieldname
 token
fieldvalue
  fieldcontent  LWS
fieldcontent
 the OCTETs making up the fieldvalue
and consisting of either TEXT or combinations
of token separators and quotedstring
The fieldcontent does not include any leading or trailing LWS
linear white space occurring before the first nonwhitespace
character of the fieldvalue or after the last nonwhitespace
character of the fieldvalue Such leading or trailing LWS MAY be
removed without changing the semantics of the field value Any LWS
that occurs between fieldcontent MAY be replaced with a single SP
before interpreting the field value or forwarding the message
downstream
The order in which header fields with differing field names are
received is not significant However it is good practice to send
generalheader fields first followed by requestheader or response
header fields and ending with the entityheader fields
Multiple messageheader fields with the same fieldname MAY be
present in a message if and only if the entire fieldvalue for that
header field is defined as a commaseparated list ie values
It MUST be possible to combine the multiple header fields into one
fieldname fieldvalue pair without changing the semantics of the
message by appending each subsequent fieldvalue to the first each
separated by a comma The order in which header fields with the same
fieldname are received is therefore significant to the
interpretation of the combined field value and thus a proxy MUST NOT
change the order of these field values when a message is forwarded
43 Message Body
The messagebody if any of an HTTP message is used to carry the
entitybody associated with the request or response The messagebody
differs from the entitybody only when a transfercoding has been
applied as indicated by the TransferEncoding header field section
1441
messagebody  entitybody
 entitybody encoded as per TransferEncoding
TransferEncoding MUST be used to indicate any transfercodings
applied by an application to ensure safe and proper transfer of the
message TransferEncoding is a property of the message not of the
Fielding et al
Standards Track
Page 32
RFC 2616
HTTP11
June 1999
entity and thus MAY be added or removed by any application along the
requestresponse chain However section 36 places restrictions on
when certain transfercodings may be used
The rules for when a messagebody is allowed in a message differ for
requests and responses
The presence of a messagebody in a request is signaled by the
inclusion of a ContentLength or TransferEncoding header field in
the requests messageheaders A messagebody MUST NOT be included in
a request if the specification of the request method section 511
does not allow sending an entitybody in requests A server SHOULD
read and forward a messagebody on any request if the request method
does not include defined semantics for an entitybody then the
messagebody SHOULD be ignored when handling the request
For response messages whether or not a messagebody is included with
a message is dependent on both the request method and the response
status code section 611 All responses to the HEAD request method
MUST NOT include a messagebody even though the presence of entity
header fields might lead one to believe they do All 1xx
informational 204 no content and 304 not modified responses
MUST NOT include a messagebody All other responses do include a
messagebody although it MAY be of zero length
44 Message Length
The transferlength of a message is the length of the messagebody as
it appears in the message that is after any transfercodings have
been applied When a messagebody is included with a message the
transferlength of that body is determined by one of the following
in order of precedence
1Any response message which MUST NOT include a messagebody such
as the 1xx 204 and 304 responses and any response to a HEAD
request is always terminated by the first empty line after the
header fields regardless of the entityheader fields present in
the message
2If a TransferEncoding header field section 1441 is present and
has any value other than identity then the transferlength is
defined by use of the chunked transfercoding section 36
unless the message is terminated by closing the connection
3If a ContentLength header field section 1413 is present its
decimal value in OCTETs represents both the entitylength and the
transferlength The ContentLength header field MUST NOT be sent
if these two lengths are different ie if a TransferEncoding
Fielding et al
Standards Track
Page 33
RFC 2616
HTTP11
June 1999
header field is present If a message is received with both a
TransferEncoding header field and a ContentLength header field
the latter MUST be ignored
4If the message uses the media type multipartbyteranges and the
ransferlength is not otherwise specified then this self
elimiting media type defines the transferlength This media type
UST NOT be used unless the sender knows that the recipient can arse
it the presence in a request of a Range header with ultiple byte
range specifiers from a 11 client implies that the lient can parse
multipartbyteranges responses
A range header might be forwarded by a 10 proxy that does not
understand multipartbyteranges in this case the server MUST
delimit the message using methods defined in items 13 or 5 of
this section
5By the server closing the connection Closing the connection
cannot be used to indicate the end of a request body since that
would leave no possibility for the server to send back a response
For compatibility with HTTP10 applications HTTP11 requests
containing a messagebody MUST include a valid ContentLength header
field unless the server is known to be HTTP11 compliant If a
request contains a messagebody and a ContentLength is not given
the server SHOULD respond with 400 bad request if it cannot
determine the length of the message or with 411 length required if
it wishes to insist on receiving a valid ContentLength
All HTTP11 applications that receive entities MUST accept the
chunked transfercoding section 36 thus allowing this mechanism
to be used for messages when the message length cannot be determined
in advance
Messages MUST NOT include both a ContentLength header field and a
nonidentity transfercoding If the message does include a non
identity transfercoding the ContentLength MUST be ignored
When a ContentLength is given in a message where a messagebody is
allowed its field value MUST exactly match the number of OCTETs in
the messagebody HTTP11 user agents MUST notify the user when an
invalid length is received and detected
45 General Header Fields
There are a few header fields which have general applicability for
both request and response messages but which do not apply to the
entity being transferred These header fields apply only to the
Fielding et al
Standards Track
Page 34
RFC 2616
HTTP11
June 1999
message being transmitted
generalheader  CacheControl
 Section 149
 Connection
 Section 1410
 Date
 Section 1418
 Pragma
 Section 1432
 Trailer
 Section 1440
 TransferEncoding
 Section 1441
 Upgrade
 Section 1442
 Via
 Section 1445
 Warning
 Section 1446
Generalheader field names can be extended reliably only in
combination with a change in the protocol version However new or
experimental header fields may be given the semantics of general
header fields if all parties in the communication recognize them to
be generalheader fields Unrecognized header fields are treated as
entityheader fields
5 Request
A request message from a client to a server includes within the
first line of that message the method to be applied to the resource
the identifier of the resource and the protocol version in use
Request
 RequestLine
 Section 51
 generalheader
 Section 45
 requestheader
 Section 53
 entityheader  CRLF
 Section 71
CRLF
 messagebody
 Section 43
51 RequestLine
The RequestLine begins with a method token followed by the
RequestURI and the protocol version and ending with CRLF The
elements are separated by SP characters No CR or LF is allowed
except in the final CRLF sequence
RequestLine
 Method SP RequestURI SP HTTPVersion CRLF
Fielding et al
Standards Track
Page 35
RFC 2616
HTTP11
June 1999
511 Method
The Method
token indicates the method to be performed on the
resource identified by the RequestURI The method is casesensitive
Method
 OPTIONS
 Section 92
 GET
 Section 93
 HEAD
 Section 94
 POST
 Section 95
 PUT
 Section 96
 DELETE
 Section 97
 TRACE
 Section 98
 CONNECT
 Section 99
 extensionmethod
extensionmethod  token
The list of methods allowed by a resource can be specified in an
Allow header field section 147 The return code of the response
always notifies the client whether a method is currently allowed on a
resource since the set of allowed methods can change dynamically An
origin server SHOULD return the status code 405 Method Not Allowed
if the method is known by the origin server but not allowed for the
requested resource and 501 Not Implemented if the method is
unrecognized or not implemented by the origin server The methods GET
and HEAD MUST be supported by all generalpurpose servers All other
methods are OPTIONAL however if the above methods are implemented
they MUST be implemented with the same semantics as those specified
in section 9
512 RequestURI
The RequestURI is a Uniform Resource Identifier section 32 and
identifies the resource upon which to apply the request
RequestURI
   absoluteURI  abs_path  authority
The four options for RequestURI are dependent on the nature of the
request The asterisk  means that the request does not apply to a
particular resource but to the server itself and is only allowed
when the method used does not necessarily apply to a resource One
example would be
OPTIONS  HTTP11
The absoluteURI form is REQUIRED when the request is being made to a
proxy The proxy is requested to forward the request or service it
from a valid cache and return the response Note that the proxy MAY
forward the request on to another proxy or directly to the server
Fielding et al
Standards Track
Page 36
RFC 2616
HTTP11
June 1999
specified by the absoluteURI In order to avoid request loops a
proxy MUST be able to recognize all of its server names including
any aliases local variations and the numeric IP address An example
RequestLine would be
GET httpwwww3orgpubWWWTheProjecthtml HTTP11
To allow for transition to absoluteURIs in all requests in future
versions of HTTP all HTTP11 servers MUST accept the absoluteURI
form in requests even though HTTP11 clients will only generate
them in requests to proxies
The authority form is only used by the CONNECT method section 99
The most common form of RequestURI is that used to identify a
resource on an origin server or gateway In this case the absolute
path of the URI MUST be transmitted see section 321 abs_path as
the RequestURI and the network location of the URI authority MUST
be transmitted in a Host header field For example a client wishing
to retrieve the resource above directly from the origin server would
create a TCP connection to port 80 of the host wwww3org and send
the lines
GET pubWWWTheProjecthtml HTTP11
Host wwww3org
followed by the remainder of the Request Note that the absolute path
cannot be empty if none is present in the original URI it MUST be
given as  the server root
The RequestURI is transmitted in the format specified in section
321 If the RequestURI is encoded using the % HEX HEX encoding
42 the origin server MUST decode the RequestURI in order to
properly interpret the request Servers SHOULD respond to invalid
RequestURIs with an appropriate status code
A transparent proxy MUST NOT rewrite the abs_path part of the
received RequestURI when forwarding it to the next inbound server
except as noted above to replace a null abs_path with
Note The no rewrite rule prevents the proxy from changing the
meaning of the request when the origin server is improperly using
a nonreserved URI character for a reserved purpose
Implementors
should be aware that some preHTTP11 proxies have been known to
rewrite the RequestURI
Fielding et al
Standards Track
Page 37
RFC 2616
HTTP11
June 1999
52 The Resource Identified by a Request
The exact resource identified by an Internet request is determined by
examining both the RequestURI and the Host header field
An origin server that does not allow resources to differ by the
requested host MAY ignore the Host header field value when
determining the resource identified by an HTTP11 request But see
section 19611 for other requirements on Host support in HTTP11
An origin server that does differentiate resources based on the host
requested sometimes referred to as virtual hosts or vanity host
names MUST use the following rules for determining the requested
resource on an HTTP11 request
1 If RequestURI is an absoluteURI the host is part of the
RequestURI Any Host header field value in the request MUST be
ignored
2 If the RequestURI is not an absoluteURI and the request includes
a Host header field the host is determined by the Host header
field value
3 If the host as determined by rule 1 or 2 is not a valid host on
the server the response MUST be a 400 Bad Request error message
Recipients of an HTTP10 request that lacks a Host header field MAY
attempt to use heuristics eg examination of the URI path for
something unique to a particular host in order to determine what
exact resource is being requested
53 Request Header Fields
The requestheader fields allow the client to pass additional
information about the request and about the client itself to the
server These fields act as request modifiers with semantics
equivalent to the parameters on a programming language method
invocation
requestheader  Accept
 Section 141
 AcceptCharset
 Section 142
 AcceptEncoding
 Section 143
 AcceptLanguage
 Section 144
 Authorization
 Section 148
 Expect
 Section 1420
 From
 Section 1422
 Host
 Section 1423
 IfMatch
 Section 1424
Fielding et al
Standards Track
Page 38
RFC 2616
HTTP11
June 1999
 IfModifiedSince
 Section 1425
 IfNoneMatch
 Section 1426
 IfRange
 Section 1427
 IfUnmodifiedSince
 Section 1428
 MaxForwards
 Section 1431
 ProxyAuthorization
 Section 1434
 Range
 Section 1435
 Referer
 Section 1436
 TE
 Section 1439
 UserAgent
 Section 1443
Requestheader field names can be extended reliably only in
combination with a change in the protocol version However new or
experimental header fields MAY be given the semantics of request
header fields if all parties in the communication recognize them to
be requestheader fields Unrecognized header fields are treated as
entityheader fields
6 Response
After receiving and interpreting a request message a server responds
with an HTTP response message
Response
 StatusLine
 Section 61
 generalheader
 Section 45
 responseheader
 Section 62
 entityheader  CRLF
 Section 71
CRLF
 messagebody
 Section 72
61 StatusLine
The first line of a Response message is the StatusLine consisting
of the protocol version followed by a numeric status code and its
associated textual phrase with each element separated by SP
characters No CR or LF is allowed except in the final CRLF sequence
StatusLine  HTTPVersion SP StatusCode SP ReasonPhrase CRLF
611 Status Code and Reason Phrase
The StatusCode element is a 3digit integer result code of the
attempt to understand and satisfy the request These codes are fully
defined in section 10 The ReasonPhrase is intended to give a short
textual description of the StatusCode The StatusCode is intended
for use by automata and the ReasonPhrase is intended for the human
user The client is not required to examine or display the Reason
Phrase
Fielding et al
Standards Track
Page 39
RFC 2616
HTTP11
June 1999
The first digit of the StatusCode defines the class of response The
last two digits do not have any categorization role There are 5
values for the first digit
 1xx Informational  Request received continuing process
 2xx Success  The action was successfully received
understood and accepted
 3xx Redirection  Further action must be taken in order to
complete the request
 4xx Client Error  The request contains bad syntax or cannot
be fulfilled
 5xx Server Error  The server failed to fulfill an apparently
valid request
The individual values of the numeric status codes defined for
HTTP11 and an example set of corresponding ReasonPhrases are
presented below The reason phrases listed here are only
recommendations  they MAY be replaced by local equivalents without
affecting the protocol
StatusCode

100
 Section 1011 Continue
 101
 Section 1012 Switching Protocols
 200
 Section 1021 OK
 201
 Section 1022 Created
 202
 Section 1023 Accepted
 203
 Section 1024 NonAuthoritative Information
 204
 Section 1025 No Content
 205
 Section 1026 Reset Content
 206
 Section 1027 Partial Content
 300
 Section 1031 Multiple Choices
 301
 Section 1032 Moved Permanently
 302
 Section 1033 Found
 303
 Section 1034 See Other
 304
 Section 1035 Not Modified
 305
 Section 1036 Use Proxy
 307
 Section 1038 Temporary Redirect
 400
 Section 1041 Bad Request
 401
 Section 1042 Unauthorized
 402
 Section 1043 Payment Required
 403
 Section 1044 Forbidden
 404
 Section 1045 Not Found
 405
 Section 1046 Method Not Allowed
 406
 Section 1047 Not Acceptable
Fielding et al
Standards Track
Page 40
RFC 2616
HTTP11
June 1999
 407
 Section 1048 Proxy Authentication Required
 408
 Section 1049 Request Timeout
 409
 Section 10410 Conflict
 410
 Section 10411 Gone
 411
 Section 10412 Length Required
 412
 Section 10413 Precondition Failed
 413
 Section 10414 Request Entity Too Large
 414
 Section 10415 RequestURI Too Large
 415
 Section 10416 Unsupported Media Type
 416
 Section 10417 Requested range not satisfiable
 417
 Section 10418 Expectation Failed
 500
 Section 1051 Internal Server Error
 501
 Section 1052 Not Implemented
 502
 Section 1053 Bad Gateway
 503
 Section 1054 Service Unavailable
 504
 Section 1055 Gateway Timeout
 505
 Section 1056 HTTP Version not supported
 extensioncode
extensioncode  3DIGIT
ReasonPhrase
 TEXT excluding CR LF
HTTP status codes are extensible HTTP applications are not required
to understand the meaning of all registered status codes though such
understanding is obviously desirable However applications MUST
understand the class of any status code as indicated by the first
digit and treat any unrecognized response as being equivalent to the
x00 status code of that class with the exception that an
unrecognized response MUST NOT be cached For example if an
unrecognized status code of 431 is received by the client it can
safely assume that there was something wrong with its request and
treat the response as if it had received a 400 status code In such
cases user agents SHOULD present to the user the entity returned
with the response since that entity is likely to include human
readable information which will explain the unusual status
62 Response Header Fields
The responseheader fields allow the server to pass additional
information about the response which cannot be placed in the Status
Line These header fields give information about the server and about
further access to the resource identified by the RequestURI
responseheader  AcceptRanges
 Section 145
 Age
 Section 146
 ETag
 Section 1419
 Location
 Section 1430
 ProxyAuthenticate
 Section 1433
Fielding et al
Standards Track
Page 41
RFC 2616
HTTP11
June 1999
 RetryAfter
 Section 1437
 Server
 Section 1438
 Vary
 Section 1444
 WWWAuthenticate
 Section 1447
Responseheader field names can be extended reliably only in
combination with a change in the protocol version However new or
experimental header fields MAY be given the semantics of response
header fields if all parties in the communication recognize them to
be responseheader fields Unrecognized header fields are treated as
entityheader fields
7 Entity
Request and Response messages MAY transfer an entity if not otherwise
restricted by the request method or response status code An entity
consists of entityheader fields and an entitybody although some
responses will only include the entityheaders
In this section both sender and recipient refer to either the client
or the server depending on who sends and who receives the entity
71 Entity Header Fields
Entityheader fields define metainformation about the entitybody or
if no body is present about the resource identified by the request
Some of this metainformation is OPTIONAL some might be REQUIRED by
portions of this specification
entityheader
 Allow
 Section 147
 ContentEncoding
 Section 1411
 ContentLanguage
 Section 1412
 ContentLength
 Section 1413
 ContentLocation
 Section 1414
 ContentMD5
 Section 1415
 ContentRange
 Section 1416
 ContentType
 Section 1417
 Expires
 Section 1421
 LastModified
 Section 1429
 extensionheader
extensionheader  messageheader
The extensionheader mechanism allows additional entityheader fields
to be defined without changing the protocol but these fields cannot
be assumed to be recognizable by the recipient Unrecognized header
fields SHOULD be ignored by the recipient and MUST be forwarded by
transparent proxies
Fielding et al
Standards Track
Page 42
RFC 2616
HTTP11
June 1999
72 Entity Body
The entitybody if any sent with an HTTP request or response is in
a format and encoding defined by the entityheader fields
entitybody
 OCTET
An entitybody is only present in a message when a messagebody is
present as described in section 43 The entitybody is obtained
from the messagebody by decoding any TransferEncoding that might
have been applied to ensure safe and proper transfer of the message
721 Type
When an entitybody is included with a message the data type of that
body is determined via the header fields ContentType and Content
Encoding These define a twolayer ordered encoding model
entitybody  ContentEncoding ContentType data
ContentType specifies the media type of the underlying data
ContentEncoding may be used to indicate any additional content
codings applied to the data usually for the purpose of data
compression that are a property of the requested resource There is
no default encoding
Any HTTP11 message containing an entitybody SHOULD include a
ContentType header field defining the media type of that body If
and only if the media type is not given by a ContentType field the
recipient MAY attempt to guess the media type via inspection of its
content andor the name extensions of the URI used to identify the
resource If the media type remains unknown the recipient SHOULD
treat it as type applicationoctetstream
722 Entity Length
The entitylength of a message is the length of the messagebody
before any transfercodings have been applied Section 44 defines
how the transferlength of a messagebody is determined
Fielding et al
Standards Track
Page 43
RFC 2616
HTTP11
June 1999
8 Connections
81 Persistent Connections
811 Purpose
Prior to persistent connections a separate TCP connection was
established to fetch each URL increasing the load on HTTP servers
and causing congestion on the Internet The use of inline images and
other associated data often require a client to make multiple
requests of the same server in a short amount of time Analysis of
these performance problems and results from a prototype
implementation are available 26 30 Implementation experience and
measurements of actual HTTP11 RFC 2068 implementations show good
results 39 Alternatives have also been explored for example
TTCP 27
Persistent HTTP connections have a number of advantages
 By opening and closing fewer TCP connections CPU time is saved
in routers and hosts clients servers proxies gateways
tunnels or caches and memory used for TCP protocol control
blocks can be saved in hosts
 HTTP requests and responses can be pipelined on a connection
Pipelining allows a client to make multiple requests without
waiting for each response allowing a single TCP connection to
be used much more efficiently with much lower elapsed time
 Network congestion is reduced by reducing the number of packets
caused by TCP opens and by allowing TCP sufficient time to
determine the congestion state of the network
 Latency on subsequent requests is reduced since there is no time
spent in TCPs connection opening handshake
 HTTP can evolve more gracefully since errors can be reported
without the penalty of closing the TCP connection Clients using
future versions of HTTP might optimistically try a new feature
but if communicating with an older server retry with old
semantics after an error is reported
HTTP implementations SHOULD implement persistent connections
Fielding et al
Standards Track
Page 44
RFC 2616
HTTP11
June 1999
812 Overall Operation
A significant difference between HTTP11 and earlier versions of
HTTP is that persistent connections are the default behavior of any
HTTP connection That is unless otherwise indicated the client
SHOULD assume that the server will maintain a persistent connection
even after error responses from the server
Persistent connections provide a mechanism by which a client and a
server can signal the close of a TCP connection This signaling takes
place using the Connection header field section 1410 Once a close
has been signaled the client MUST NOT send any more requests on that
connection
8121 Negotiation
An HTTP11 server MAY assume that a HTTP11 client intends to
maintain a persistent connection unless a Connection header including
the connectiontoken close was sent in the request If the server
chooses to close the connection immediately after sending the
response it SHOULD send a Connection header including the
connectiontoken close
An HTTP11 client MAY expect a connection to remain open but would
decide to keep it open based on whether the response from a server
contains a Connection header with the connectiontoken close In case
the client does not want to maintain a connection for more than that
request it SHOULD send a Connection header including the
connectiontoken close
If either the client or the server sends the close token in the
Connection header that request becomes the last one for the
connection
Clients and servers SHOULD NOT assume that a persistent connection is
maintained for HTTP versions less than 11 unless it is explicitly
signaled See section 1962 for more information on backward
compatibility with HTTP10 clients
In order to remain persistent all messages on the connection MUST
have a selfdefined message length ie one not defined by closure
of the connection as described in section 44
Fielding et al
Standards Track
Page 45
RFC 2616
HTTP11
June 1999
8122 Pipelining
A client that supports persistent connections MAY pipeline its
requests ie send multiple requests without waiting for each
response A server MUST send its responses to those requests in the
same order that the requests were received
Clients which assume persistent connections and pipeline immediately
after connection establishment SHOULD be prepared to retry their
connection if the first pipelined attempt fails If a client does
such a retry it MUST NOT pipeline before it knows the connection is
persistent Clients MUST also be prepared to resend their requests if
the server closes the connection before sending all of the
corresponding responses
Clients SHOULD NOT pipeline requests using nonidempotent methods or
nonidempotent sequences of methods see section 912 Otherwise a
premature termination of the transport connection could lead to
indeterminate results A client wishing to send a nonidempotent
request SHOULD wait to send that request until it has received the
response status for the previous request
813 Proxy Servers
It is especially important that proxies correctly implement the
properties of the Connection header field as specified in section
1410
The proxy server MUST signal persistent connections separately with
its clients and the origin servers or other proxy servers that it
connects to Each persistent connection applies to only one transport
link
A proxy server MUST NOT establish a HTTP11 persistent connection
with an HTTP10 client but see RFC 2068 33 for information and
discussion of the problems with the KeepAlive header implemented by
many HTTP10 clients
814 Practical Considerations
Servers will usually have some timeout value beyond which they will
no longer maintain an inactive connection Proxy servers might make
this a higher value since it is likely that the client will be making
more connections through the same server The use of persistent
connections places no requirements on the length or existence of
this timeout for either the client or the server
Fielding et al
Standards Track
Page 46
RFC 2616
HTTP11
June 1999
When a client or server wishes to timeout it SHOULD issue a graceful
close on the transport connection Clients and servers SHOULD both
constantly watch for the other side of the transport close and
respond to it as appropriate If a client or server does not detect
the other sides close promptly it could cause unnecessary resource
drain on the network
A client server or proxy MAY close the transport connection at any
time For example a client might have started to send a new request
at the same time that the server has decided to close the idle
connection From the servers point of view the connection is being
closed while it was idle but from the clients point of view a
request is in progress
This means that clients servers and proxies MUST be able to recover
from asynchronous close events Client software SHOULD reopen the
transport connection and retransmit the aborted sequence of requests
without user interaction so long as the request sequence is
idempotent see section 912 Nonidempotent methods or sequences
MUST NOT be automatically retried although user agents MAY offer a
human operator the choice of retrying the requests Confirmation by
useragent software with semantic understanding of the application
MAY substitute for user confirmation The automatic retry SHOULD NOT
be repeated if the second sequence of requests fails
Servers SHOULD always respond to at least one request per connection
if at all possible Servers SHOULD NOT close a connection in the
middle of transmitting a response unless a network or client failure
is suspected
Clients that use persistent connections SHOULD limit the number of
simultaneous connections that they maintain to a given server A
singleuser client SHOULD NOT maintain more than 2 connections with
any server or proxy A proxy SHOULD use up to 2N connections to
another server or proxy where N is the number of simultaneously
active users These guidelines are intended to improve HTTP response
times and avoid congestion
82 Message Transmission Requirements
821 Persistent Connections and Flow Control
HTTP11 servers SHOULD maintain persistent connections and use TCPs
flow control mechanisms to resolve temporary overloads rather than
terminating connections with the expectation that clients will retry
The latter technique can exacerbate network congestion
Fielding et al
Standards Track
Page 47
RFC 2616
HTTP11
June 1999
822 Monitoring Connections for Error Status Messages
An HTTP11 or later client sending a messagebody SHOULD monitor
the network connection for an error status while it is transmitting
the request If the client sees an error status it SHOULD
immediately cease transmitting the body If the body is being sent
using a chunked encoding section 36 a zero length chunk and
empty trailer MAY be used to prematurely mark the end of the message
If the body was preceded by a ContentLength header the client MUST
close the connection
823 Use of the 100 Continue Status
The purpose of the 100 Continue status see section 1011 is to
allow a client that is sending a request message with a request body
to determine if the origin server is willing to accept the request
based on the request headers before the client sends the request
body In some cases it might either be inappropriate or highly
inefficient for the client to send the body if the server will reject
the message without looking at the body
Requirements for HTTP11 clients
 If a client will wait for a 100 Continue response before
sending the request body it MUST send an Expect requestheader
field section 1420 with the 100continue expectation
 A client MUST NOT send an Expect requestheader field section
1420 with the 100continue expectation if it does not intend
to send a request body
Because of the presence of older implementations the protocol allows
ambiguous situations in which a client may send Expect 100
continue without receiving either a 417 Expectation Failed status
or a 100 Continue status Therefore when a client sends this
header field to an origin server possibly via a proxy from which it
has never seen a 100 Continue status the client SHOULD NOT wait
for an indefinite period before sending the request body
Requirements for HTTP11 origin servers
 Upon receiving a request which includes an Expect requestheader
field with the 100continue expectation an origin server MUST
either respond with 100 Continue status and continue to read
from the input stream or respond with a final status code The
origin server MUST NOT wait for the request body before sending
the 100 Continue response If it responds with a final status
code it MAY close the transport connection or it MAY continue
Fielding et al
Standards Track
Page 48
RFC 2616
HTTP11
June 1999
to read and discard the rest of the request
It MUST NOT
perform the requested method if it returns a final status code
 An origin server SHOULD NOT send a 100 Continue response if
the request message does not include an Expect requestheader
field with the 100continue expectation and MUST NOT send a
100 Continue response if such a request comes from an HTTP10
or earlier client There is an exception to this rule for
compatibility with RFC 2068 a server MAY send a 100 Continue
status in response to an HTTP11 PUT or POST request that does
not include an Expect requestheader field with the 100
continue expectation This exception the purpose of which is
to minimize any client processing delays associated with an
undeclared wait for 100 Continue status applies only to
HTTP11 requests and not to requests with any other HTTP
version value
 An origin server MAY omit a 100 Continue response if it has
already received some or all of the request body for the
corresponding request
 An origin server that sends a 100 Continue response MUST
ultimately send a final status code once the request body is
received and processed unless it terminates the transport
connection prematurely
 If an origin server receives a request that does not include an
Expect requestheader field with the 100continue expectation
the request includes a request body and the server responds
with a final status code before reading the entire request body
from the transport connection then the server SHOULD NOT close
the transport connection until it has read the entire request
or until the client closes the connection Otherwise the client
might not reliably receive the response message However this
requirement is not be construed as preventing a server from
defending itself against denialofservice attacks or from
badly broken client implementations
Requirements for HTTP11 proxies
 If a proxy receives a request that includes an Expect request
header field with the 100continue expectation and the proxy
either knows that the nexthop server complies with HTTP11 or
higher or does not know the HTTP version of the nexthop
server it MUST forward the request including the Expect header
field
Fielding et al
Standards Track
Page 49
RFC 2616
HTTP11
June 1999
 If the proxy knows that the version of the nexthop server is
HTTP10 or lower it MUST NOT forward the request and it MUST
respond with a 417 Expectation Failed status
 Proxies SHOULD maintain a cache recording the HTTP version
numbers received from recentlyreferenced nexthop servers
 A proxy MUST NOT forward a 100 Continue response if the
request message was received from an HTTP10 or earlier
client and did not include an Expect requestheader field with
the 100continue expectation This requirement overrides the
general rule for forwarding of 1xx responses see section 101
824 Client Behavior if Server Prematurely Closes Connection
If an HTTP11 client sends a request which includes a request body
but which does not include an Expect requestheader field with the
100continue expectation and if the client is not directly
connected to an HTTP11 origin server and if the client sees the
connection close before receiving any status from the server the
client SHOULD retry the request
If the client does retry this
request it MAY use the following binary exponential backoff
algorithm to be assured of obtaining a reliable response
1 Initiate a new connection to the server
2 Transmit the requestheaders
3 Initialize a variable R to the estimated roundtrip time to the
server eg based on the time it took to establish the
connection or to a constant value of 5 seconds if the round
trip time is not available
4 Compute T  R  2N where N is the number of previous
retries of this request
5 Wait either for an error response from the server or for T
seconds whichever comes first
6 If no error response is received after T seconds transmit the
body of the request
7 If client sees that the connection is closed prematurely
repeat from step 1 until the request is accepted an error
response is received or the user becomes impatient and
terminates the retry process
Fielding et al
Standards Track
Page 50
RFC 2616
HTTP11
June 1999
If at any point an error status is received the client
 SHOULD NOT continue and
 SHOULD close the connection if it has not completed sending the
request message
9 Method Definitions
The set of common methods for HTTP11 is defined below Although
this set can be expanded additional methods cannot be assumed to
share the same semantics for separately extended clients and servers
The Host requestheader field section 1423 MUST accompany all
HTTP11 requests
91 Safe and Idempotent Methods
911 Safe Methods
Implementors should be aware that the software represents the user in
their interactions over the Internet and should be careful to allow
the user to be aware of any actions they might take which may have an
unexpected significance to themselves or others
In particular the convention has been established that the GET and
HEAD methods SHOULD NOT have the significance of taking an action
other than retrieval These methods ought to be considered safe
This allows user agents to represent other methods such as POST PUT
and DELETE in a special way so that the user is made aware of the
fact that a possibly unsafe action is being requested
Naturally it is not possible to ensure that the server does not
generate sideeffects as a result of performing a GET request in
fact some dynamic resources consider that a feature The important
distinction here is that the user did not request the sideeffects
so therefore cannot be held accountable for them
912 Idempotent Methods
Methods can also have the property of idempotence in that aside
from error or expiration issues the sideeffects of N  0 identical
requests is the same as for a single request The methods GET HEAD
PUT and DELETE share this property Also the methods OPTIONS and
TRACE SHOULD NOT have side effects and so are inherently idempotent
Fielding et al
Standards Track
Page 51
RFC 2616
HTTP11
June 1999
However it is possible that a sequence of several requests is non
idempotent even if all of the methods executed in that sequence are
idempotent A sequence is idempotent if a single execution of the
entire sequence always yields a result that is not changed by a
reexecution of all or part of that sequence For example a
sequence is nonidempotent if its result depends on a value that is
later modified in the same sequence
A sequence that never has side effects is idempotent by definition
provided that no concurrent operations are being executed on the
same set of resources
92 OPTIONS
The OPTIONS method represents a request for information about the
communication options available on the requestresponse chain
identified by the RequestURI This method allows the client to
determine the options andor requirements associated with a resource
or the capabilities of a server without implying a resource action
or initiating a resource retrieval
Responses to this method are not cacheable
If the OPTIONS request includes an entitybody as indicated by the
presence of ContentLength or TransferEncoding then the media type
MUST be indicated by a ContentType field Although this
specification does not define any use for such a body future
extensions to HTTP might use the OPTIONS body to make more detailed
queries on the server A server that does not support such an
extension MAY discard the request body
If the RequestURI is an asterisk  the OPTIONS request is
intended to apply to the server in general rather than to a specific
resource Since a servers communication options typically depend on
the resource the  request is only useful as a ping or noop
type of method it does nothing beyond allowing the client to test
the capabilities of the server For example this can be used to test
a proxy for HTTP11 compliance or lack thereof
If the RequestURI is not an asterisk the OPTIONS request applies
only to the options that are available when communicating with that
resource
A 200 response SHOULD include any header fields that indicate
optional features implemented by the server and applicable to that
resource eg Allow possibly including extensions not defined by
this specification The response body if any SHOULD also include
information about the communication options The format for such a
Fielding et al
Standards Track
Page 52
RFC 2616
HTTP11
June 1999
body is not defined by this specification but might be defined by
future extensions to HTTP Content negotiation MAY be used to select
the appropriate response format If no response body is included the
response MUST include a ContentLength field with a fieldvalue of
0
The MaxForwards requestheader field MAY be used to target a
specific proxy in the request chain When a proxy receives an OPTIONS
request on an absoluteURI for which request forwarding is permitted
the proxy MUST check for a MaxForwards field If the MaxForwards
fieldvalue is zero 0 the proxy MUST NOT forward the message
instead the proxy SHOULD respond with its own communication options
If the MaxForwards fieldvalue is an integer greater than zero the
proxy MUST decrement the fieldvalue when it forwards the request If
no MaxForwards field is present in the request then the forwarded
request MUST NOT include a MaxForwards field
93 GET
The GET method means retrieve whatever information in the form of an
entity is identified by the RequestURI If the RequestURI refers
to a dataproducing process it is the produced data which shall be
returned as the entity in the response and not the source text of the
process unless that text happens to be the output of the process
The semantics of the GET method change to a conditional GET if the
request message includes an IfModifiedSince IfUnmodifiedSince
IfMatch IfNoneMatch or IfRange header field A conditional GET
method requests that the entity be transferred only under the
circumstances described by the conditional header fields The
conditional GET method is intended to reduce unnecessary network
usage by allowing cached entities to be refreshed without requiring
multiple requests or transferring data already held by the client
The semantics of the GET method change to a partial GET if the
request message includes a Range header field A partial GET requests
that only part of the entity be transferred as described in section
1435 The partial GET method is intended to reduce unnecessary
network usage by allowing partiallyretrieved entities to be
completed without transferring data already held by the client
The response to a GET request is cacheable if and only if it meets
the requirements for HTTP caching described in section 13
See section 1513 for security considerations when used for forms
Fielding et al
Standards Track
Page 53
RFC 2616
HTTP11
June 1999
94 HEAD
The HEAD method is identical to GET except that the server MUST NOT
return a messagebody in the response The metainformation contained
in the HTTP headers in response to a HEAD request SHOULD be identical
to the information sent in response to a GET request This method can
be used for obtaining metainformation about the entity implied by the
request without transferring the entitybody itself This method is
often used for testing hypertext links for validity accessibility
and recent modification
The response to a HEAD request MAY be cacheable in the sense that the
information contained in the response MAY be used to update a
previously cached entity from that resource If the new field values
indicate that the cached entity differs from the current entity as
would be indicated by a change in ContentLength ContentMD5 ETag
or LastModified then the cache MUST treat the cache entry as
stale
95 POST
The POST method is used to request that the origin server accept the
entity enclosed in the request as a new subordinate of the resource
identified by the RequestURI in the RequestLine POST is designed
to allow a uniform method to cover the following functions
 Annotation of existing resources
 Posting a message to a bulletin board newsgroup mailing list
or similar group of articles
 Providing a block of data such as the result of submitting a
form to a datahandling process
 Extending a database through an append operation
The actual function performed by the POST method is determined by the
server and is usually dependent on the RequestURI The posted entity
is subordinate to that URI in the same way that a file is subordinate
to a directory containing it a news article is subordinate to a
newsgroup to which it is posted or a record is subordinate to a
database
The action performed by the POST method might not result in a
resource that can be identified by a URI In this case either 200
OK or 204 No Content is the appropriate response status
depending on whether or not the response includes an entity that
describes the result
Fielding et al
Standards Track
Page 54
RFC 2616
HTTP11
June 1999
If a resource has been created on the origin server the response
SHOULD be 201 Created and contain an entity which describes the
status of the request and refers to the new resource and a Location
header see section 1430
Responses to this method are not cacheable unless the response
includes appropriate CacheControl or Expires header fields However
the 303 See Other response can be used to direct the user agent to
retrieve a cacheable resource
POST requests MUST obey the message transmission requirements set out
in section 82
See section 1513 for security considerations
96 PUT
The PUT method requests that the enclosed entity be stored under the
supplied RequestURI If the RequestURI refers to an already
existing resource the enclosed entity SHOULD be considered as a
modified version of the one residing on the origin server If the
RequestURI does not point to an existing resource and that URI is
capable of being defined as a new resource by the requesting user
agent the origin server can create the resource with that URI If a
new resource is created the origin server MUST inform the user agent
via the 201 Created response If an existing resource is modified
either the 200 OK or 204 No Content response codes SHOULD be sent
to indicate successful completion of the request If the resource
could not be created or modified with the RequestURI an appropriate
error response SHOULD be given that reflects the nature of the
problem The recipient of the entity MUST NOT ignore any Content
eg ContentRange headers that it does not understand or implement
and MUST return a 501 Not Implemented response in such cases
If the request passes through a cache and the RequestURI identifies
one or more currently cached entities those entries SHOULD be
treated as stale Responses to this method are not cacheable
The fundamental difference between the POST and PUT requests is
reflected in the different meaning of the RequestURI The URI in a
POST request identifies the resource that will handle the enclosed
entity That resource might be a dataaccepting process a gateway to
some other protocol or a separate entity that accepts annotations
In contrast the URI in a PUT request identifies the entity enclosed
with the request  the user agent knows what URI is intended and the
server MUST NOT attempt to apply the request to some other resource
If the server desires that the request be applied to a different URI
Fielding et al
Standards Track
Page 55
RFC 2616
HTTP11
June 1999
it MUST send a 301 Moved Permanently response the user agent MAY
then make its own decision regarding whether or not to redirect the
request
A single resource MAY be identified by many different URIs For
example an article might have a URI for identifying the current
version which is separate from the URI identifying each particular
version In this case a PUT request on a general URI might result in
several other URIs being defined by the origin server
HTTP11 does not define how a PUT method affects the state of an
origin server
PUT requests MUST obey the message transmission requirements set out
in section 82
Unless otherwise specified for a particular entityheader the
entityheaders in the PUT request SHOULD be applied to the resource
created or modified by the PUT
97 DELETE
The DELETE method requests that the origin server delete the resource
identified by the RequestURI This method MAY be overridden by human
intervention or other means on the origin server The client cannot
be guaranteed that the operation has been carried out even if the
status code returned from the origin server indicates that the action
has been completed successfully However the server SHOULD NOT
indicate success unless at the time the response is given it
intends to delete the resource or move it to an inaccessible
location
A successful response SHOULD be 200 OK if the response includes an
entity describing the status 202 Accepted if the action has not
yet been enacted or 204 No Content if the action has been enacted
but the response does not include an entity
If the request passes through a cache and the RequestURI identifies
one or more currently cached entities those entries SHOULD be
treated as stale Responses to this method are not cacheable
98 TRACE
The TRACE method is used to invoke a remote applicationlayer loop
back of the request message The final recipient of the request
SHOULD reflect the message received back to the client as the
entitybody of a 200 OK response The final recipient is either the
Fielding et al
Standards Track
Page 56
RFC 2616
HTTP11
June 1999
origin server or the first proxy or gateway to receive a MaxForwards
value of zero 0 in the request see section 1431 A TRACE request
MUST NOT include an entity
TRACE allows the client to see what is being received at the other
end of the request chain and use that data for testing or diagnostic
information The value of the Via header field section 1445 is of
particular interest since it acts as a trace of the request chain
Use of the MaxForwards header field allows the client to limit the
length of the request chain which is useful for testing a chain of
proxies forwarding messages in an infinite loop
If the request is valid the response SHOULD contain the entire
request message in the entitybody with a ContentType of
messagehttp Responses to this method MUST NOT be cached
99 CONNECT
This specification reserves the method name CONNECT for use with a
proxy that can dynamically switch to being a tunnel eg SSL
tunneling 44
10 Status Code Definitions
Each StatusCode is described below including a description of which
methods it can follow and any metainformation required in the
response
101 Informational 1xx
This class of status code indicates a provisional response
consisting only of the StatusLine and optional headers and is
terminated by an empty line There are no required headers for this
class of status code Since HTTP10 did not define any 1xx status
codes servers MUST NOT send a 1xx response to an HTTP10 client
except under experimental conditions
A client MUST be prepared to accept one or more 1xx status responses
prior to a regular response even if the client does not expect a 100
Continue status message Unexpected 1xx status responses MAY be
ignored by a user agent
Proxies MUST forward 1xx responses unless the connection between the
proxy and its client has been closed or unless the proxy itself
requested the generation of the 1xx response For example if a
Fielding et al
Standards Track
Page 57
RFC 2616
HTTP11
June 1999
proxy adds a Expect 100continue field when it forwards a request
then it need not forward the corresponding 100 Continue
responses
1011 100 Continue
The client SHOULD continue with its request This interim response is
used to inform the client that the initial part of the request has
been received and has not yet been rejected by the server The client
SHOULD continue by sending the remainder of the request or if the
request has already been completed ignore this response The server
MUST send a final response after the request has been completed See
section 823 for detailed discussion of the use and handling of this
status code
1012 101 Switching Protocols
The server understands and is willing to comply with the clients
request via the Upgrade message header field section 1442 for a
change in the application protocol being used on this connection The
server will switch protocols to those defined by the responses
Upgrade header field immediately after the empty line which
terminates the 101 response
The protocol SHOULD be switched only when it is advantageous to do
so For example switching to a newer version of HTTP is advantageous
over older versions and switching to a realtime synchronous
protocol might be advantageous when delivering resources that use
such features
102 Successful 2xx
This class of status code indicates that the clients request was
successfully received understood and accepted
1021 200 OK
The request has succeeded The information returned with the response
is dependent on the method used in the request for example
GET
an entity corresponding to the requested resource is sent in
the response
HEAD
the entityheader fields corresponding to the requested
resource are sent in the response without any messagebody
POST
an entity describing or containing the result of the action
Fielding et al
Standards Track
Page 58
RFC 2616
HTTP11
June 1999
TRACE
an entity containing the request message as received by the
end server
1022 201 Created
The request has been fulfilled and resulted in a new resource being
created The newly created resource can be referenced by the URIs
returned in the entity of the response with the most specific URI
for the resource given by a Location header field The response
SHOULD include an entity containing a list of resource
characteristics and locations from which the user or user agent can
choose the one most appropriate The entity format is specified by
the media type given in the ContentType header field The origin
server MUST create the resource before returning the 201 status code
If the action cannot be carried out immediately the server SHOULD
respond with 202 Accepted response instead
A 201 response MAY contain an ETag response header field indicating
the current value of the entity tag for the requested variant just
created see section 1419
1023 202 Accepted
The request has been accepted for processing but the processing has
not been completed
The request might or might not eventually be
acted upon as it might be disallowed when processing actually takes
place There is no facility for resending a status code from an
asynchronous operation such as this
The 202 response is intentionally noncommittal Its purpose is to
allow a server to accept a request for some other process perhaps a
batchoriented process that is only run once per day without
requiring that the user agents connection to the server persist
until the process is completed The entity returned with this
response SHOULD include an indication of the requests current status
and either a pointer to a status monitor or some estimate of when the
user can expect the request to be fulfilled
1024 203 NonAuthoritative Information
The returned metainformation in the entityheader is not the
definitive set as available from the origin server but is gathered
from a local or a thirdparty copy The set presented MAY be a subset
or superset of the original version For example including local
annotation information about the resource might result in a superset
of the metainformation known by the origin server Use of this
response code is not required and is only appropriate when the
response would otherwise be 200 OK
Fielding et al
Standards Track
Page 59
RFC 2616
HTTP11
June 1999
1025 204 No Content
The server has fulfilled the request but does not need to return an
entitybody and might want to return updated metainformation The
response MAY include new or updated metainformation in the form of
entityheaders which if present SHOULD be associated with the
requested variant
If the client is a user agent it SHOULD NOT change its document view
from that which caused the request to be sent This response is
primarily intended to allow input for actions to take place without
causing a change to the user agents active document view although
any new or updated metainformation SHOULD be applied to the document
currently in the user agents active view
The 204 response MUST NOT include a messagebody and thus is always
terminated by the first empty line after the header fields
1026 205 Reset Content
The server has fulfilled the request and the user agent SHOULD reset
the document view which caused the request to be sent This response
is primarily intended to allow input for actions to take place via
user input followed by a clearing of the form in which the input is
given so that the user can easily initiate another input action The
response MUST NOT include an entity
1027 206 Partial Content
The server has fulfilled the partial GET request for the resource
The request MUST have included a Range header field section 1435
indicating the desired range and MAY have included an IfRange
header field section 1427 to make the request conditional
The response MUST include the following header fields
 Either a ContentRange header field section 1416 indicating
the range included with this response or a multipartbyteranges
ContentType including ContentRange fields for each part If a
ContentLength header field is present in the response its
value MUST match the actual number of OCTETs transmitted in the
messagebody
 Date
 ETag andor ContentLocation if the header would have been sent
in a 200 response to the same request
Fielding et al
Standards Track
Page 60
RFC 2616
HTTP11
June 1999
 Expires CacheControl andor Vary if the fieldvalue might
differ from that sent in any previous response for the same
variant
If the 206 response is the result of an IfRange request that used a
strong cache validator see section 1333 the response SHOULD NOT
include other entityheaders If the response is the result of an
IfRange request that used a weak validator the response MUST NOT
include other entityheaders this prevents inconsistencies between
cached entitybodies and updated headers Otherwise the response
MUST include all of the entityheaders that would have been returned
with a 200 OK response to the same request
A cache MUST NOT combine a 206 response with other previously cached
content if the ETag or LastModified headers do not match exactly
see 1354
A cache that does not support the Range and ContentRange headers
MUST NOT cache 206 Partial responses
103 Redirection 3xx
This class of status code indicates that further action needs to be
taken by the user agent in order to fulfill the request
The action
required MAY be carried out by the user agent without interaction
with the user if and only if the method used in the second request is
GET or HEAD A client SHOULD detect infinite redirection loops since
such loops generate network traffic for each redirection
Note previous versions of this specification recommended a
maximum of five redirections Content developers should be aware
that there might be clients that implement such a fixed
limitation
1031 300 Multiple Choices
The requested resource corresponds to any one of a set of
representations each with its own specific location and agent
driven negotiation information section 12 is being provided so that
the user or user agent can select a preferred representation and
redirect its request to that location
Unless it was a HEAD request the response SHOULD include an entity
containing a list of resource characteristics and locations from
which the user or user agent can choose the one most appropriate The
entity format is specified by the media type given in the Content
Type header field Depending upon the format and the capabilities of
Fielding et al
Standards Track
Page 61
RFC 2616
HTTP11
June 1999
the user agent selection of the most appropriate choice MAY be
performed automatically However this specification does not define
any standard for such automatic selection
If the server has a preferred choice of representation it SHOULD
include the specific URI for that representation in the Location
field user agents MAY use the Location field value for automatic
redirection This response is cacheable unless indicated otherwise
1032 301 Moved Permanently
The requested resource has been assigned a new permanent URI and any
future references to this resource SHOULD use one of the returned
URIs
Clients with link editing capabilities ought to automatically
relink references to the RequestURI to one or more of the new
references returned by the server where possible This response is
cacheable unless indicated otherwise
The new permanent URI SHOULD be given by the Location field in the
response Unless the request method was HEAD the entity of the
response SHOULD contain a short hypertext note with a hyperlink to
the new URIs
If the 301 status code is received in response to a request other
than GET or HEAD the user agent MUST NOT automatically redirect the
request unless it can be confirmed by the user since this might
change the conditions under which the request was issued
Note When automatically redirecting a POST request after
receiving a 301 status code some existing HTTP10 user agents
will erroneously change it into a GET request
1033 302 Found
The requested resource resides temporarily under a different URI
Since the redirection might be altered on occasion the client SHOULD
continue to use the RequestURI for future requests
This response
is only cacheable if indicated by a CacheControl or Expires header
field
The temporary URI SHOULD be given by the Location field in the
response Unless the request method was HEAD the entity of the
response SHOULD contain a short hypertext note with a hyperlink to
the new URIs
Fielding et al
Standards Track
Page 62
RFC 2616
HTTP11
June 1999
If the 302 status code is received in response to a request other
than GET or HEAD the user agent MUST NOT automatically redirect the
request unless it can be confirmed by the user since this might
change the conditions under which the request was issued
Note RFC 1945 and RFC 2068 specify that the client is not allowed
to change the method on the redirected request
However most
existing user agent implementations treat 302 as if it were a 303
response performing a GET on the Location fieldvalue regardless
of the original request method The status codes 303 and 307 have
been added for servers that wish to make unambiguously clear which
kind of reaction is expected of the client
1034 303 See Other
The response to the request can be found under a different URI and
SHOULD be retrieved using a GET method on that resource This method
exists primarily to allow the output of a POSTactivated script to
redirect the user agent to a selected resource The new URI is not a
substitute reference for the originally requested resource The 303
response MUST NOT be cached but the response to the second
redirected request might be cacheable
The different URI SHOULD be given by the Location field in the
response Unless the request method was HEAD the entity of the
response SHOULD contain a short hypertext note with a hyperlink to
the new URIs
Note Many preHTTP11 user agents do not understand the 303
status When interoperability with such clients is a concern the
302 status code may be used instead since most user agents react
to a 302 response as described here for 303
1035 304 Not Modified
If the client has performed a conditional GET request and access is
allowed but the document has not been modified the server SHOULD
respond with this status code The 304 response MUST NOT contain a
messagebody and thus is always terminated by the first empty line
after the header fields
The response MUST include the following header fields
 Date unless its omission is required by section 14181
Fielding et al
Standards Track
Page 63
RFC 2616
HTTP11
June 1999
If a clockless origin server obeys these rules and proxies and
clients add their own Date to any response received without one as
already specified by RFC 2068 section 1419 caches will operate
correctly
 ETag andor ContentLocation if the header would have been sent
in a 200 response to the same request
 Expires CacheControl andor Vary if the fieldvalue might
differ from that sent in any previous response for the same
variant
If the conditional GET used a strong cache validator see section
1333 the response SHOULD NOT include other entityheaders
Otherwise ie the conditional GET used a weak validator the
response MUST NOT include other entityheaders this prevents
inconsistencies between cached entitybodies and updated headers
If a 304 response indicates an entity not currently cached then the
cache MUST disregard the response and repeat the request without the
conditional
If a cache uses a received 304 response to update a cache entry the
cache MUST update the entry to reflect any new field values given in
the response
1036 305 Use Proxy
The requested resource MUST be accessed through the proxy given by
the Location field The Location field gives the URI of the proxy
The recipient is expected to repeat this single request via the
proxy 305 responses MUST only be generated by origin servers
Note RFC 2068 was not clear that 305 was intended to redirect a
single request and to be generated by origin servers only
Not
observing these limitations has significant security consequences
1037 306 Unused
The 306 status code was used in a previous version of the
specification is no longer used and the code is reserved
Fielding et al
Standards Track
Page 64
RFC 2616
HTTP11
June 1999
1038 307 Temporary Redirect
The requested resource resides temporarily under a different URI
Since the redirection MAY be altered on occasion the client SHOULD
continue to use the RequestURI for future requests
This response
is only cacheable if indicated by a CacheControl or Expires header
field
The temporary URI SHOULD be given by the Location field in the
response Unless the request method was HEAD the entity of the
response SHOULD contain a short hypertext note with a hyperlink to
the new URIs  since many preHTTP11 user agents do not
understand the 307 status Therefore the note SHOULD contain the
information necessary for a user to repeat the original request on
the new URI
If the 307 status code is received in response to a request other
than GET or HEAD the user agent MUST NOT automatically redirect the
request unless it can be confirmed by the user since this might
change the conditions under which the request was issued
104 Client Error 4xx
The 4xx class of status code is intended for cases in which the
client seems to have erred Except when responding to a HEAD request
the server SHOULD include an entity containing an explanation of the
error situation and whether it is a temporary or permanent
condition These status codes are applicable to any request method
User agents SHOULD display any included entity to the user
If the client is sending data a server implementation using TCP
SHOULD be careful to ensure that the client acknowledges receipt of
the packets containing the response before the server closes the
input connection If the client continues sending data to the server
after the close the servers TCP stack will send a reset packet to
the client which may erase the clients unacknowledged input buffers
before they can be read and interpreted by the HTTP application
1041 400 Bad Request
The request could not be understood by the server due to malformed
syntax The client SHOULD NOT repeat the request without
modifications
Fielding et al
Standards Track
Page 65
RFC 2616
HTTP11
June 1999
1042 401 Unauthorized
The request requires user authentication The response MUST include a
WWWAuthenticate header field section 1447 containing a challenge
applicable to the requested resource The client MAY repeat the
request with a suitable Authorization header field section 148 If
the request already included Authorization credentials then the 401
response indicates that authorization has been refused for those
credentials If the 401 response contains the same challenge as the
prior response and the user agent has already attempted
authentication at least once then the user SHOULD be presented the
entity that was given in the response since that entity might
include relevant diagnostic information HTTP access authentication
is explained in HTTP Authentication Basic and Digest Access
Authentication 43
1043 402 Payment Required
This code is reserved for future use
1044 403 Forbidden
The server understood the request but is refusing to fulfill it
Authorization will not help and the request SHOULD NOT be repeated
If the request method was not HEAD and the server wishes to make
public why the request has not been fulfilled it SHOULD describe the
reason for the refusal in the entity
If the server does not wish to
make this information available to the client the status code 404
Not Found can be used instead
1045 404 Not Found
The server has not found anything matching the RequestURI No
indication is given of whether the condition is temporary or
permanent The 410 Gone status code SHOULD be used if the server
knows through some internally configurable mechanism that an old
resource is permanently unavailable and has no forwarding address
This status code is commonly used when the server does not wish to
reveal exactly why the request has been refused or when no other
response is applicable
1046 405 Method Not Allowed
The method specified in the RequestLine is not allowed for the
resource identified by the RequestURI The response MUST include an
Allow header containing a list of valid methods for the requested
resource
Fielding et al
Standards Track
Page 66
RFC 2616
HTTP11
June 1999
1047 406 Not Acceptable
The resource identified by the request is only capable of generating
response entities which have content characteristics not acceptable
according to the accept headers sent in the request
Unless it was a HEAD request the response SHOULD include an entity
containing a list of available entity characteristics and locations
from which the user or user agent can choose the one most
appropriate The entity format is specified by the media type given
in the ContentType header field Depending upon the format and the
capabilities of the user agent selection of the most appropriate
choice MAY be performed automatically However this specification
does not define any standard for such automatic selection
Note HTTP11 servers are allowed to return responses which are
not acceptable according to the accept headers sent in the
request In some cases this may even be preferable to sending a
406 response User agents are encouraged to inspect the headers of
an incoming response to determine if it is acceptable
If the response could be unacceptable a user agent SHOULD
temporarily stop receipt of more data and query the user for a
decision on further actions
1048 407 Proxy Authentication Required
This code is similar to 401 Unauthorized but indicates that the
client must first authenticate itself with the proxy The proxy MUST
return a ProxyAuthenticate header field section 1433 containing a
challenge applicable to the proxy for the requested resource The
client MAY repeat the request with a suitable ProxyAuthorization
header field section 1434 HTTP access authentication is explained
in HTTP Authentication Basic and Digest Access Authentication
43
1049 408 Request Timeout
The client did not produce a request within the time that the server
was prepared to wait The client MAY repeat the request without
modifications at any later time
10410 409 Conflict
The request could not be completed due to a conflict with the current
state of the resource This code is only allowed in situations where
it is expected that the user might be able to resolve the conflict
and resubmit the request The response body SHOULD include enough
Fielding et al
Standards Track
Page 67
RFC 2616
HTTP11
June 1999
information for the user to recognize the source of the conflict
Ideally the response entity would include enough information for the
user or user agent to fix the problem however that might not be
possible and is not required
Conflicts are most likely to occur in response to a PUT request For
example if versioning were being used and the entity being PUT
included changes to a resource which conflict with those made by an
earlier thirdparty request the server might use the 409 response
to indicate that it cant complete the request In this case the
response entity would likely contain a list of the differences
between the two versions in a format defined by the response
ContentType
10411 410 Gone
The requested resource is no longer available at the server and no
forwarding address is known This condition is expected to be
considered permanent Clients with link editing capabilities SHOULD
delete references to the RequestURI after user approval If the
server does not know or has no facility to determine whether or not
the condition is permanent the status code 404 Not Found SHOULD be
used instead This response is cacheable unless indicated otherwise
The 410 response is primarily intended to assist the task of web
maintenance by notifying the recipient that the resource is
intentionally unavailable and that the server owners desire that
remote links to that resource be removed Such an event is common for
limitedtime promotional services and for resources belonging to
individuals no longer working at the servers site It is not
necessary to mark all permanently unavailable resources as gone or
to keep the mark for any length of time  that is left to the
discretion of the server owner
10412 411 Length Required
The server refuses to accept the request without a defined Content
Length The client MAY repeat the request if it adds a valid
ContentLength header field containing the length of the messagebody
in the request message
10413 412 Precondition Failed
The precondition given in one or more of the requestheader fields
evaluated to false when it was tested on the server This response
code allows the client to place preconditions on the current resource
metainformation header field data and thus prevent the requested
method from being applied to a resource other than the one intended
Fielding et al
Standards Track
Page 68
RFC 2616
HTTP11
June 1999
10414 413 Request Entity Too Large
The server is refusing to process a request because the request
entity is larger than the server is willing or able to process The
server MAY close the connection to prevent the client from continuing
the request
If the condition is temporary the server SHOULD include a Retry
After header field to indicate that it is temporary and after what
time the client MAY try again
10415 414 RequestURI Too Long
The server is refusing to service the request because the RequestURI
is longer than the server is willing to interpret This rare
condition is only likely to occur when a client has improperly
converted a POST request to a GET request with long query
information when the client has descended into a URI black hole of
redirection eg a redirected URI prefix that points to a suffix of
itself or when the server is under attack by a client attempting to
exploit security holes present in some servers using fixedlength
buffers for reading or manipulating the RequestURI
10416 415 Unsupported Media Type
The server is refusing to service the request because the entity of
the request is in a format not supported by the requested resource
for the requested method
10417 416 Requested Range Not Satisfiable
A server SHOULD return a response with this status code if a request
included a Range requestheader field section 1435 and none of
the rangespecifier values in this field overlap the current extent
of the selected resource and the request did not include an IfRange
requestheader field For byteranges this means that the first
bytepos of all of the byterangespec values were greater than the
current length of the selected resource
When this status code is returned for a byterange request the
response SHOULD include a ContentRange entityheader field
specifying the current length of the selected resource see section
1416 This response MUST NOT use the multipartbyteranges content
type
Fielding et al
Standards Track
Page 69
RFC 2616
HTTP11
June 1999
10418 417 Expectation Failed
The expectation given in an Expect requestheader field see section
1420 could not be met by this server or if the server is a proxy
the server has unambiguous evidence that the request could not be met
by the nexthop server
105 Server Error 5xx
Response status codes beginning with the digit 5 indicate cases in
which the server is aware that it has erred or is incapable of
performing the request Except when responding to a HEAD request the
server SHOULD include an entity containing an explanation of the
error situation and whether it is a temporary or permanent
condition User agents SHOULD display any included entity to the
user These response codes are applicable to any request method
1051 500 Internal Server Error
The server encountered an unexpected condition which prevented it
from fulfilling the request
1052 501 Not Implemented
The server does not support the functionality required to fulfill the
request This is the appropriate response when the server does not
recognize the request method and is not capable of supporting it for
any resource
1053 502 Bad Gateway
The server while acting as a gateway or proxy received an invalid
response from the upstream server it accessed in attempting to
fulfill the request
1054 503 Service Unavailable
The server is currently unable to handle the request due to a
temporary overloading or maintenance of the server The implication
is that this is a temporary condition which will be alleviated after
some delay If known the length of the delay MAY be indicated in a
RetryAfter header If no RetryAfter is given the client SHOULD
handle the response as it would for a 500 response
Note The existence of the 503 status code does not imply that a
server must use it when becoming overloaded Some servers may wish
to simply refuse the connection
Fielding et al
Standards Track
Page 70
RFC 2616
HTTP11
June 1999
1055 504 Gateway Timeout
The server while acting as a gateway or proxy did not receive a
timely response from the upstream server specified by the URI eg
HTTP FTP LDAP or some other auxiliary server eg DNS it needed
to access in attempting to complete the request
Note Note to implementors some deployed proxies are known to
return 400 or 500 when DNS lookups time out
1056 505 HTTP Version Not Supported
The server does not support or refuses to support the HTTP protocol
version that was used in the request message The server is
indicating that it is unable or unwilling to complete the request
using the same major version as the client as described in section
31 other than with this error message The response SHOULD contain
an entity describing why that version is not supported and what other
protocols are supported by that server
11 Access Authentication
HTTP provides several OPTIONAL challengeresponse authentication
mechanisms which can be used by a server to challenge a client
request and by a client to provide authentication information The
general framework for access authentication and the specification of
basic and digest authentication are specified in HTTP
Authentication Basic and Digest Access Authentication 43 This
specification adopts the definitions of challenge and credentials
from that specification
12 Content Negotiation
Most HTTP responses include an entity which contains information for
interpretation by a human user Naturally it is desirable to supply
the user with the best available entity corresponding to the
request Unfortunately for servers and caches not all users have the
same preferences for what is best and not all user agents are
equally capable of rendering all entity types For that reason HTTP
has provisions for several mechanisms for content negotiation
the process of selecting the best representation for a given response
when there are multiple representations available
Note This is not called format negotiation because the
alternate representations may be of the same media type but use
different capabilities of that type be in different languages
etc
Fielding et al
Standards Track
Page 71
RFC 2616
HTTP11
June 1999
Any response containing an entitybody MAY be subject to negotiation
including error responses
There are two kinds of content negotiation which are possible in
HTTP serverdriven and agentdriven negotiation These two kinds of
negotiation are orthogonal and thus may be used separately or in
combination One method of combination referred to as transparent
negotiation occurs when a cache uses the agentdriven negotiation
information provided by the origin server in order to provide
serverdriven negotiation for subsequent requests
121 Serverdriven Negotiation
If the selection of the best representation for a response is made by
an algorithm located at the server it is called serverdriven
negotiation Selection is based on the available representations of
the response the dimensions over which it can vary eg language
contentcoding etc and the contents of particular header fields in
the request message or on other information pertaining to the request
such as the network address of the client
Serverdriven negotiation is advantageous when the algorithm for
selecting from among the available representations is difficult to
describe to the user agent or when the server desires to send its
best guess to the client along with the first response hoping to
avoid the roundtrip delay of a subsequent request if the best
guess is good enough for the user In order to improve the servers
guess the user agent MAY include request header fields Accept
AcceptLanguage AcceptEncoding etc which describe its
preferences for such a response
Serverdriven negotiation has disadvantages
1 It is impossible for the server to accurately determine what
might be best for any given user since that would require
complete knowledge of both the capabilities of the user agent
and the intended use for the response eg does the user want
to view it on screen or print it on paper
2 Having the user agent describe its capabilities in every
request can be both very inefficient given that only a small
percentage of responses have multiple representations and a
potential violation of the users privacy
3 It complicates the implementation of an origin server and the
algorithms for generating responses to a request
Fielding et al
Standards Track
Page 72
RFC 2616
HTTP11
June 1999
4 It may limit a public caches ability to use the same response
for multiple users requests
HTTP11 includes the following requestheader fields for enabling
serverdriven negotiation through description of user agent
capabilities and user preferences Accept section 141 Accept
Charset section 142 AcceptEncoding section 143 Accept
Language section 144 and UserAgent section 1443 However an
origin server is not limited to these dimensions and MAY vary the
response based on any aspect of the request including information
outside the requestheader fields or within extension header fields
not defined by this specification
The Vary
header field can be used to express the parameters the
server uses to select a representation that is subject to server
driven negotiation See section 136 for use of the Vary header field
by caches and section 1444 for use of the Vary header field by
servers
122 Agentdriven Negotiation
With agentdriven negotiation selection of the best representation
for a response is performed by the user agent after receiving an
initial response from the origin server Selection is based on a list
of the available representations of the response included within the
header fields or entitybody of the initial response with each
representation identified by its own URI Selection from among the
representations may be performed automatically if the user agent is
capable of doing so or manually by the user selecting from a
generated possibly hypertext menu
Agentdriven negotiation is advantageous when the response would vary
over commonlyused dimensions such as type language or encoding
when the origin server is unable to determine a user agents
capabilities from examining the request and generally when public
caches are used to distribute server load and reduce network usage
Agentdriven negotiation suffers from the disadvantage of needing a
second request to obtain the best alternate representation This
second request is only efficient when caching is used In addition
this specification does not define any mechanism for supporting
automatic selection though it also does not prevent any such
mechanism from being developed as an extension and used within
HTTP11
Fielding et al
Standards Track
Page 73
RFC 2616
HTTP11
June 1999
HTTP11 defines the 300 Multiple Choices and 406 Not Acceptable
status codes for enabling agentdriven negotiation when the server is
unwilling or unable to provide a varying response using serverdriven
negotiation
123 Transparent Negotiation
Transparent negotiation is a combination of both serverdriven and
agentdriven negotiation When a cache is supplied with a form of the
list of available representations of the response as in agentdriven
negotiation and the dimensions of variance are completely understood
by the cache then the cache becomes capable of performing server
driven negotiation on behalf of the origin server for subsequent
requests on that resource
Transparent negotiation has the advantage of distributing the
negotiation work that would otherwise be required of the origin
server and also removing the second request delay of agentdriven
negotiation when the cache is able to correctly guess the right
response
This specification does not define any mechanism for transparent
negotiation though it also does not prevent any such mechanism from
being developed as an extension that could be used within HTTP11
13 Caching in HTTP
HTTP is typically used for distributed information systems where
performance can be improved by the use of response caches The
HTTP11 protocol includes a number of elements intended to make
caching work as well as possible Because these elements are
inextricable from other aspects of the protocol and because they
interact with each other it is useful to describe the basic caching
design of HTTP separately from the detailed descriptions of methods
headers response codes etc
Caching would be useless if it did not significantly improve
performance The goal of caching in HTTP11 is to eliminate the need
to send requests in many cases and to eliminate the need to send
full responses in many other cases The former reduces the number of
network roundtrips required for many operations we use an
expiration mechanism for this purpose see section 132 The
latter reduces network bandwidth requirements we use a validation
mechanism for this purpose see section 133
Requirements for performance availability and disconnected
operation require us to be able to relax the goal of semantic
transparency The HTTP11 protocol allows origin servers caches
Fielding et al
Standards Track
Page 74
RFC 2616
HTTP11
June 1999
and clients to explicitly reduce transparency when necessary
However because nontransparent operation may confuse nonexpert
users and might be incompatible with certain server applications
such as those for ordering merchandise the protocol requires that
transparency be relaxed
 only by an explicit protocollevel request when relaxed by
client or origin server
 only with an explicit warning to the end user when relaxed by
cache or client
Therefore the HTTP11 protocol provides these important elements
1 Protocol features that provide full semantic transparency when
this is required by all parties
2 Protocol features that allow an origin server or user agent to
explicitly request and control nontransparent operation
3 Protocol features that allow a cache to attach warnings to
responses that do not preserve the requested approximation of
semantic transparency
A basic principle is that it must be possible for the clients to
detect any potential relaxation of semantic transparency
Note The server cache or client implementor might be faced with
design decisions not explicitly discussed in this specification
If a decision might affect semantic transparency the implementor
ought to err on the side of maintaining transparency unless a
careful and complete analysis shows significant benefits in
breaking transparency
1311 Cache Correctness
A correct cache MUST respond to a request with the most uptodate
response held by the cache that is appropriate to the request see
sections 1325 1326 and 1312 which meets one of the following
conditions
1 It has been checked for equivalence with what the origin server
would have returned by revalidating the response with the
origin server section 133
Fielding et al
Standards Track
Page 75
RFC 2616
HTTP11
June 1999
2 It is fresh enough see section 132 In the default case
this means it meets the least restrictive freshness requirement
of the client origin server and cache see section 149 if
the origin server so specifies it is the freshness requirement
of the origin server alone
If a stored response is not fresh enough by the most
restrictive freshness requirement of both the client and the
origin server in carefully considered circumstances the cache
MAY still return the response with the appropriate Warning
header see section 1315 and 1446 unless such a response
is prohibited eg by a nostore cachedirective or by a
nocache cacherequestdirective see section 149
3 It is an appropriate 304 Not Modified 305 Proxy Redirect
or error 4xx or 5xx response message
If the cache can not communicate with the origin server then a
correct cache SHOULD respond as above if the response can be
correctly served from the cache if not it MUST return an error or
warning indicating that there was a communication failure
If a cache receives a response either an entire response or a 304
Not Modified response that it would normally forward to the
requesting client and the received response is no longer fresh the
cache SHOULD forward it to the requesting client without adding a new
Warning but without removing any existing Warning headers A cache
SHOULD NOT attempt to revalidate a response simply because that
response became stale in transit this might lead to an infinite
loop A user agent that receives a stale response without a Warning
MAY display a warning indication to the user
1312 Warnings
Whenever a cache returns a response that is neither firsthand nor
fresh enough in the sense of condition 2 in section 1311 it
MUST attach a warning to that effect using a Warning generalheader
The Warning header and the currently defined warnings are described
in section 1446 The warning allows clients to take appropriate
action
Warnings MAY be used for other purposes both cacherelated and
otherwise The use of a warning rather than an error status code
distinguish these responses from true failures
Warnings are assigned three digit warncodes The first digit
indicates whether the Warning MUST or MUST NOT be deleted from a
stored cache entry after a successful revalidation
Fielding et al
Standards Track
Page 76
RFC 2616
HTTP11
June 1999
1xx
Warnings that describe the freshness or revalidation status of
the response and so MUST be deleted after a successful
revalidation 1XX warncodes MAY be generated by a cache only when
validating a cached entry It MUST NOT be generated by clients
2xx
Warnings that describe some aspect of the entity body or entity
headers that is not rectified by a revalidation for example a
lossy compression of the entity bodies and which MUST NOT be
deleted after a successful revalidation
See section 1446 for the definitions of the codes themselves
HTTP10 caches will cache all Warnings in responses without
deleting the ones in the first category Warnings in responses that
are passed to HTTP10 caches carry an extra warningdate field
which prevents a future HTTP11 recipient from believing an
erroneously cached Warning
Warnings also carry a warning text The text MAY be in any
appropriate natural language perhaps based on the clients Accept
headers and include an OPTIONAL indication of what character set is
used
Multiple warnings MAY be attached to a response either by the origin
server or by a cache including multiple warnings with the same code
number For example a server might provide the same warning with
texts in both English and Basque
When multiple warnings are attached to a response it might not be
practical or reasonable to display all of them to the user This
version of HTTP does not specify strict priority rules for deciding
which warnings to display and in what order but does suggest some
heuristics
1313 Cachecontrol Mechanisms
The basic cache mechanisms in HTTP11 serverspecified expiration
times and validators are implicit directives to caches In some
cases a server or client might need to provide explicit directives
to the HTTP caches We use the CacheControl header for this purpose
The CacheControl header allows a client or server to transmit a
variety of directives in either requests or responses These
directives typically override the default caching algorithms As a
general rule if there is any apparent conflict between header
values the most restrictive interpretation is applied that is the
one that is most likely to preserve semantic transparency However
Fielding et al
Standards Track
Page 77
RFC 2616
HTTP11
June 1999
in some cases cachecontrol directives are explicitly specified as
weakening the approximation of semantic transparency for example
maxstale or public
The cachecontrol directives are described in detail in section 149
1314 Explicit User Agent Warnings
Many user agents make it possible for users to override the basic
caching mechanisms For example the user agent might allow the user
to specify that cached entities even explicitly stale ones are
never validated Or the user agent might habitually add Cache
Control maxstale3600 to every request The user agent SHOULD NOT
default to either nontransparent behavior or behavior that results
in abnormally ineffective caching but MAY be explicitly configured
to do so by an explicit action of the user
If the user has overridden the basic caching mechanisms the user
agent SHOULD explicitly indicate to the user whenever this results in
the display of information that might not meet the servers
transparency requirements in particular if the displayed entity is
known to be stale Since the protocol normally allows the user agent
to determine if responses are stale or not this indication need only
be displayed when this actually happens The indication need not be a
dialog box it could be an icon for example a picture of a rotting
fish or some other indicator
If the user has overridden the caching mechanisms in a way that would
abnormally reduce the effectiveness of caches the user agent SHOULD
continually indicate this state to the user for example by a
display of a picture of currency in flames so that the user does not
inadvertently consume excess resources or suffer from excessive
latency
1315 Exceptions to the Rules and Warnings
In some cases the operator of a cache MAY choose to configure it to
return stale responses even when not requested by clients This
decision ought not be made lightly but may be necessary for reasons
of availability or performance especially when the cache is poorly
connected to the origin server Whenever a cache returns a stale
response it MUST mark it as such using a Warning header enabling
the client software to alert the user that there might be a potential
problem
Fielding et al
Standards Track
Page 78
RFC 2616
HTTP11
June 1999
It also allows the user agent to take steps to obtain a firsthand or
fresh response For this reason a cache SHOULD NOT return a stale
response if the client explicitly requests a firsthand or fresh one
unless it is impossible to comply for technical or policy reasons
1316 Clientcontrolled Behavior
While the origin server and to a lesser extent intermediate caches
by their contribution to the age of a response are the primary
source of expiration information in some cases the client might need
to control a caches decision about whether to return a cached
response without validating it Clients do this using several
directives of the CacheControl header
A clients request MAY specify the maximum age it is willing to
accept of an unvalidated response specifying a value of zero forces
the caches to revalidate all responses A client MAY also specify
the minimum time remaining before a response expires Both of these
options increase constraints on the behavior of caches and so cannot
further relax the caches approximation of semantic transparency
A client MAY also specify that it will accept stale responses up to
some maximum amount of staleness This loosens the constraints on the
caches and so might violate the origin servers specified
constraints on semantic transparency but might be necessary to
support disconnected operation or high availability in the face of
poor connectivity
132 Expiration Model
1321 ServerSpecified Expiration
HTTP caching works best when caches can entirely avoid making
requests to the origin server The primary mechanism for avoiding
requests is for an origin server to provide an explicit expiration
time in the future indicating that a response MAY be used to satisfy
subsequent requests In other words a cache can return a fresh
response without first contacting the server
Our expectation is that servers will assign future explicit
expiration times to responses in the belief that the entity is not
likely to change in a semantically significant way before the
expiration time is reached This normally preserves semantic
transparency as long as the servers expiration times are carefully
chosen
Fielding et al
Standards Track
Page 79
RFC 2616
HTTP11
June 1999
The expiration mechanism applies only to responses taken from a cache
and not to firsthand responses forwarded immediately to the
requesting client
If an origin server wishes to force a semantically transparent cache
to validate every request it MAY assign an explicit expiration time
in the past This means that the response is always stale and so the
cache SHOULD validate it before using it for subsequent requests See
section 1494 for a more restrictive way to force revalidation
If an origin server wishes to force any HTTP11 cache no matter how
it is configured to validate every request it SHOULD use the must
revalidate cachecontrol directive see section 149
Servers specify explicit expiration times using either the Expires
header or the maxage directive of the CacheControl header
An expiration time cannot be used to force a user agent to refresh
its display or reload a resource its semantics apply only to caching
mechanisms and such mechanisms need only check a resources
expiration status when a new request for that resource is initiated
See section 1313 for an explanation of the difference between caches
and history mechanisms
1322 Heuristic Expiration
Since origin servers do not always provide explicit expiration times
HTTP caches typically assign heuristic expiration times employing
algorithms that use other header values such as the LastModified
time to estimate a plausible expiration time The HTTP11
specification does not provide specific algorithms but does impose
worstcase constraints on their results Since heuristic expiration
times might compromise semantic transparency they ought to used
cautiously and we encourage origin servers to provide explicit
expiration times as much as possible
1323 Age Calculations
In order to know if a cached entry is fresh a cache needs to know if
its age exceeds its freshness lifetime We discuss how to calculate
the latter in section 1324 this section describes how to calculate
the age of a response or cache entry
In this discussion we use the term now to mean the current value
of the clock at the host performing the calculation Hosts that use
HTTP but especially hosts running origin servers and caches SHOULD
use NTP 28 or some similar protocol to synchronize their clocks to
a globally accurate time standard
Fielding et al
Standards Track
Page 80
RFC 2616
HTTP11
June 1999
HTTP11 requires origin servers to send a Date header if possible
with every response giving the time at which the response was
generated see section 1418 We use the term date_value to denote
the value of the Date header in a form appropriate for arithmetic
operations
HTTP11 uses the Age responseheader to convey the estimated age of
the response message when obtained from a cache The Age field value
is the caches estimate of the amount of time since the response was
generated or revalidated by the origin server
In essence the Age value is the sum of the time that the response
has been resident in each of the caches along the path from the
origin server plus the amount of time it has been in transit along
network paths
We use the term age_value to denote the value of the Age header in
a form appropriate for arithmetic operations
A responses age can be calculated in two entirely independent ways
1 now minus date_value if the local clock is reasonably well
synchronized to the origin servers clock If the result is
negative the result is replaced by zero
2 age_value if all of the caches along the response path
implement HTTP11
Given that we have two independent ways to compute the age of a
response when it is received we can combine these as
corrected_received_age  maxnow  date_value age_value
and as long as we have either nearly synchronized clocks or all
HTTP11 paths one gets a reliable conservative result
Because of networkimposed delays some significant interval might
pass between the time that a server generates a response and the time
it is received at the next outbound cache or client If uncorrected
this delay could result in improperly low ages
Because the request that resulted in the returned Age value must have
been initiated prior to that Age values generation we can correct
for delays imposed by the network by recording the time at which the
request was initiated Then when an Age value is received it MUST
be interpreted relative to the time the request was initiated not
Fielding et al
Standards Track
Page 81
RFC 2616
HTTP11
June 1999
the time that the response was received This algorithm results in
conservative behavior no matter how much delay is experienced So we
compute
corrected_initial_age  corrected_received_age
+ now  request_time
where request_time is the time according to the local clock when
the request that elicited this response was sent
Summary of age calculation algorithm when a cache receives a
response

 age_value

is the value of Age header received by the cache with

this response
 date_value

is the value of the origin servers Date header
 request_time

is the local time when the cache made the request

that resulted in this cached response
 response_time

is the local time when the cache received the

response
 now

is the current local time

apparent_age  max0 response_time  date_value
corrected_received_age  maxapparent_age age_value
response_delay  response_time  request_time
corrected_initial_age  corrected_received_age + response_delay
resident_time  now  response_time
current_age
 corrected_initial_age + resident_time
The current_age of a cache entry is calculated by adding the amount
of time in seconds since the cache entry was last validated by the
origin server to the corrected_initial_age When a response is
generated from a cache entry the cache MUST include a single Age
header field in the response with a value equal to the cache entrys
current_age
The presence of an Age header field in a response implies that a
response is not firsthand However the converse is not true since
the lack of an Age header field in a response does not imply that the
Fielding et al
Standards Track
Page 82
RFC 2616
HTTP11
June 1999
response is firsthand unless all caches along the request path are
compliant with HTTP11 ie older HTTP caches did not implement
the Age header field
1324 Expiration Calculations
In order to decide whether a response is fresh or stale we need to
compare its freshness lifetime to its age The age is calculated as
described in section 1323 this section describes how to calculate
the freshness lifetime and to determine if a response has expired
In the discussion below the values can be represented in any form
appropriate for arithmetic operations
We use the term expires_value to denote the value of the Expires
header We use the term max_age_value to denote an appropriate
value of the number of seconds carried by the maxage directive of
the CacheControl header in a response see section 1493
The maxage directive takes priority over Expires so if maxage is
present in a response the calculation is simply
freshness_lifetime  max_age_value
Otherwise if Expires is present in the response the calculation is
freshness_lifetime  expires_value  date_value
Note that neither of these calculations is vulnerable to clock skew
since all of the information comes from the origin server
If none of Expires CacheControl maxage or CacheControl s
maxage see section 1493 appears in the response and the response
does not include other restrictions on caching the cache MAY compute
a freshness lifetime using a heuristic The cache MUST attach Warning
113 to any response whose age is more than 24 hours if such warning
has not already been added
Also if the response does have a LastModified time the heuristic
expiration value SHOULD be no more than some fraction of the interval
since that time A typical setting of this fraction might be 10%
The calculation to determine if a response has expired is quite
simple
response_is_fresh  freshness_lifetime  current_age
Fielding et al
Standards Track
Page 83
RFC 2616
HTTP11
June 1999
1325 Disambiguating Expiration Values
Because expiration values are assigned optimistically it is possible
for two caches to contain fresh values for the same resource that are
different
If a client performing a retrieval receives a nonfirsthand response
for a request that was already fresh in its own cache and the Date
header in its existing cache entry is newer than the Date on the new
response then the client MAY ignore the response If so it MAY
retry the request with a CacheControl maxage0 directive see
section 149 to force a check with the origin server
If a cache has two fresh responses for the same representation with
different validators it MUST use the one with the more recent Date
header This situation might arise because the cache is pooling
responses from other caches or because a client has asked for a
reload or a revalidation of an apparently fresh cache entry
1326 Disambiguating Multiple Responses
Because a client might be receiving responses via multiple paths so
that some responses flow through one set of caches and other
responses flow through a different set of caches a client might
receive responses in an order different from that in which the origin
server sent them We would like the client to use the most recently
generated response even if older responses are still apparently
fresh
Neither the entity tag nor the expiration value can impose an
ordering on responses since it is possible that a later response
intentionally carries an earlier expiration time The Date values are
ordered to a granularity of one second
When a client tries to revalidate a cache entry and the response it
receives contains a Date header that appears to be older than the one
for the existing entry then the client SHOULD repeat the request
unconditionally and include
CacheControl maxage0
to force any intermediate caches to validate their copies directly
with the origin server or
CacheControl nocache
to force any intermediate caches to obtain a new copy from the origin
server
Fielding et al
Standards Track
Page 84
RFC 2616
HTTP11
June 1999
If the Date values are equal then the client MAY use either response
or MAY if it is being extremely prudent request a new response
Servers MUST NOT depend on clients being able to choose
deterministically between responses generated during the same second
if their expiration times overlap
133 Validation Model
When a cache has a stale entry that it would like to use as a
response to a clients request it first has to check with the origin
server or possibly an intermediate cache with a fresh response to
see if its cached entry is still usable We call this validating
the cache entry Since we do not want to have to pay the overhead of
retransmitting the full response if the cached entry is good and we
do not want to pay the overhead of an extra round trip if the cached
entry is invalid the HTTP11 protocol supports the use of
conditional methods
The key protocol features for supporting conditional methods are
those concerned with cache validators When an origin server
generates a full response it attaches some sort of validator to it
which is kept with the cache entry When a client user agent or
proxy cache makes a conditional request for a resource for which it
has a cache entry it includes the associated validator in the
request
The server then checks that validator against the current validator
for the entity and if they match see section 1333 it responds
with a special status code usually 304 Not Modified and no
entitybody Otherwise it returns a full response including
entitybody Thus we avoid transmitting the full response if the
validator matches and we avoid an extra round trip if it does not
match
In HTTP11 a conditional request looks exactly the same as a normal
request for the same resource except that it carries a special
header which includes the validator that implicitly turns the
method usually GET into a conditional
The protocol includes both positive and negative senses of cache
validating conditions That is it is possible to request either that
a method be performed if and only if a validator matches or if and
only if no validators match
Fielding et al
Standards Track
Page 85
RFC 2616
HTTP11
June 1999
Note a response that lacks a validator may still be cached and
served from cache until it expires unless this is explicitly
prohibited by a cachecontrol directive However a cache cannot
do a conditional retrieval if it does not have a validator for the
entity which means it will not be refreshable after it expires
1331 LastModified Dates
The LastModified entityheader field value is often used as a cache
validator In simple terms a cache entry is considered to be valid
if the entity has not been modified since the LastModified value
1332 Entity Tag Cache Validators
The ETag responseheader field value an entity tag provides for an
opaque cache validator This might allow more reliable validation
in situations where it is inconvenient to store modification dates
where the onesecond resolution of HTTP date values is not
sufficient or where the origin server wishes to avoid certain
paradoxes that might arise from the use of modification dates
Entity Tags are described in section 311 The headers used with
entity tags are described in sections 1419 1424 1426 and 1444
1333 Weak and Strong Validators
Since both origin servers and caches will compare two validators to
decide if they represent the same or different entities one normally
would expect that if the entity the entitybody or any entity
headers changes in any way then the associated validator would
change as well If this is true then we call this validator a
strong validator
However there might be cases when a server prefers to change the
validator only on semantically significant changes and not when
insignificant aspects of the entity change A validator that does not
always change when the resource changes is a weak validator
Entity tags are normally strong validators but the protocol
provides a mechanism to tag an entity tag as weak One can think of
a strong validator as one that changes whenever the bits of an entity
changes while a weak value changes whenever the meaning of an entity
changes Alternatively one can think of a strong validator as part
of an identifier for a specific entity while a weak validator is
part of an identifier for a set of semantically equivalent entities
Note One example of a strong validator is an integer that is
incremented in stable storage every time an entity is changed
Fielding et al
Standards Track
Page 86
RFC 2616
HTTP11
June 1999
An entitys modification time if represented with onesecond
resolution could be a weak validator since it is possible that
the resource might be modified twice during a single second
Support for weak validators is optional However weak validators
allow for more efficient caching of equivalent objects for
example a hit counter on a site is probably good enough if it is
updated every few days or weeks and any value during that period
is likely good enough to be equivalent
A use of a validator is either when a client generates a request
and includes the validator in a validating header field or when a
server compares two validators
Strong validators are usable in any context Weak validators are only
usable in contexts that do not depend on exact equality of an entity
For example either kind is usable for a conditional GET of a full
entity However only a strong validator is usable for a subrange
retrieval since otherwise the client might end up with an internally
inconsistent entity
Clients MAY issue simple nonsubrange GET requests with either weak
validators or strong validators Clients MUST NOT use weak validators
in other forms of request
The only function that the HTTP11 protocol defines on validators is
comparison There are two validator comparison functions depending
on whether the comparison context allows the use of weak validators
or not
 The strong comparison function in order to be considered equal
both validators MUST be identical in every way and both MUST
NOT be weak
 The weak comparison function in order to be considered equal
both validators MUST be identical in every way but either or
both of them MAY be tagged as weak without affecting the
result
An entity tag is strong unless it is explicitly tagged as weak
Section 311 gives the syntax for entity tags
A LastModified time when used as a validator in a request is
implicitly weak unless it is possible to deduce that it is strong
using the following rules
 The validator is being compared by an origin server to the
actual current validator for the entity and
Fielding et al
Standards Track
Page 87
RFC 2616
HTTP11
June 1999
 That origin server reliably knows that the associated entity did
not change twice during the second covered by the presented
validator
or
 The validator is about to be used by a client in an If
ModifiedSince or IfUnmodifiedSince header because the client
has a cache entry for the associated entity and
 That cache entry includes a Date value which gives the time
when the origin server sent the original response and
 The presented LastModified time is at least 60 seconds before
the Date value
or
 The validator is being compared by an intermediate cache to the
validator stored in its cache entry for the entity and
 That cache entry includes a Date value which gives the time
when the origin server sent the original response and
 The presented LastModified time is at least 60 seconds before
the Date value
This method relies on the fact that if two different responses were
sent by the origin server during the same second but both had the
same LastModified time then at least one of those responses would
have a Date value equal to its LastModified time The arbitrary 60
second limit guards against the possibility that the Date and Last
Modified values are generated from different clocks or at somewhat
different times during the preparation of the response An
implementation MAY use a value larger than 60 seconds if it is
believed that 60 seconds is too short
If a client wishes to perform a subrange retrieval on a value for
which it has only a LastModified time and no opaque validator it
MAY do this only if the LastModified time is strong in the sense
described here
A cache or origin server receiving a conditional request other than
a fullbody GET request MUST use the strong comparison function to
evaluate the condition
These rules allow HTTP11 caches and clients to safely perform sub
range retrievals on values that have been obtained from HTTP10
Fielding et al
Standards Track
Page 88
RFC 2616
HTTP11
June 1999
servers
1334 Rules for When to Use Entity Tags and LastModified Dates
We adopt a set of rules and recommendations for origin servers
clients and caches regarding when various validator types ought to
be used and for what purposes
HTTP11 origin servers
 SHOULD send an entity tag validator unless it is not feasible to
generate one
 MAY send a weak entity tag instead of a strong entity tag if
performance considerations support the use of weak entity tags
or if it is unfeasible to send a strong entity tag
 SHOULD send a LastModified value if it is feasible to send one
unless the risk of a breakdown in semantic transparency that
could result from using this date in an IfModifiedSince header
would lead to serious problems
In other words the preferred behavior for an HTTP11 origin server
is to send both a strong entity tag and a LastModified value
In order to be legal a strong entity tag MUST change whenever the
associated entity value changes in any way A weak entity tag SHOULD
change whenever the associated entity changes in a semantically
significant way
Note in order to provide semantically transparent caching an
origin server must avoid reusing a specific strong entity tag
value for two different entities or reusing a specific weak
entity tag value for two semantically different entities Cache
entries might persist for arbitrarily long periods regardless of
expiration times so it might be inappropriate to expect that a
cache will never again attempt to validate an entry using a
validator that it obtained at some point in the past
HTTP11 clients
 If an entity tag has been provided by the origin server MUST
use that entity tag in any cacheconditional request using If
Match or IfNoneMatch
 If only a LastModified value has been provided by the origin
server SHOULD use that value in nonsubrange cacheconditional
requests using IfModifiedSince
Fielding et al
Standards Track
Page 89
RFC 2616
HTTP11
June 1999
 If only a LastModified value has been provided by an HTTP10
origin server MAY use that value in subrange cacheconditional
requests using IfUnmodifiedSince The user agent SHOULD
provide a way to disable this in case of difficulty
 If both an entity tag and a LastModified value have been
provided by the origin server SHOULD use both validators in
cacheconditional requests This allows both HTTP10 and
HTTP11 caches to respond appropriately
An HTTP11 origin server upon receiving a conditional request that
includes both a LastModified date eg in an IfModifiedSince or
IfUnmodifiedSince header field and one or more entity tags eg
in an IfMatch IfNoneMatch or IfRange header field as cache
validators MUST NOT return a response status of 304 Not Modified
unless doing so is consistent with all of the conditional header
fields in the request
An HTTP11 caching proxy upon receiving a conditional request that
includes both a LastModified date and one or more entity tags as
cache validators MUST NOT return a locally cached response to the
client unless that cached response is consistent with all of the
conditional header fields in the request
Note The general principle behind these rules is that HTTP11
servers and clients should transmit as much nonredundant
information as is available in their responses and requests
HTTP11 systems receiving this information will make the most
conservative assumptions about the validators they receive
HTTP10 clients and caches will ignore entity tags Generally
lastmodified values received or used by these systems will
support transparent and efficient caching and so HTTP11 origin
servers should provide LastModified values In those rare cases
where the use of a LastModified value as a validator by an
HTTP10 system could result in a serious problem then HTTP11
origin servers should not provide one
1335 Nonvalidating Conditionals
The principle behind entity tags is that only the service author
knows the semantics of a resource well enough to select an
appropriate cache validation mechanism and the specification of any
validator comparison function more complex than byteequality would
open up a can of worms Thus comparisons of any other headers
except LastModified for compatibility with HTTP10 are never
used for purposes of validating a cache entry
Fielding et al
Standards Track
Page 90
RFC 2616
HTTP11
June 1999
134 Response Cacheability
Unless specifically constrained by a cachecontrol section 149
directive a caching system MAY always store a successful response
see section 138 as a cache entry MAY return it without validation
if it is fresh and MAY return it after successful validation If
there is neither a cache validator nor an explicit expiration time
associated with a response we do not expect it to be cached but
certain caches MAY violate this expectation for example when little
or no network connectivity is available A client can usually detect
that such a response was taken from a cache by comparing the Date
header to the current time
Note some HTTP10 caches are known to violate this expectation
without providing any Warning
However in some cases it might be inappropriate for a cache to
retain an entity or to return it in response to a subsequent
request This might be because absolute semantic transparency is
deemed necessary by the service author or because of security or
privacy considerations Certain cachecontrol directives are
therefore provided so that the server can indicate that certain
resource entities or portions thereof are not to be cached
regardless of other considerations
Note that section 148 normally prevents a shared cache from saving
and returning a response to a previous request if that request
included an Authorization header
A response received with a status code of 200 203 206 300 301 or
410 MAY be stored by a cache and used in reply to a subsequent
request subject to the expiration mechanism unless a cachecontrol
directive prohibits caching However a cache that does not support
the Range and ContentRange headers MUST NOT cache 206 Partial
Content responses
A response received with any other status code eg status codes 302
and 307 MUST NOT be returned in a reply to a subsequent request
unless there are cachecontrol directives or another headers that
explicitly allow it For example these include the following an
Expires header section 1421 a maxage smaxage
must
revalidate proxyrevalidate public or private cachecontrol
directive section 149
Fielding et al
Standards Track
Page 91
RFC 2616
HTTP11
June 1999
135 Constructing Responses From Caches
The purpose of an HTTP cache is to store information received in
response to requests for use in responding to future requests In
many cases a cache simply returns the appropriate parts of a
response to the requester However if the cache holds a cache entry
based on a previous response it might have to combine parts of a new
response with what is held in the cache entry
1351 Endtoend and Hopbyhop Headers
For the purpose of defining the behavior of caches and noncaching
proxies we divide HTTP headers into two categories
 Endtoend headers which are
transmitted to the ultimate
recipient of a request or response Endtoend headers in
responses MUST be stored as part of a cache entry and MUST be
transmitted in any response formed from a cache entry
 Hopbyhop headers which are meaningful only for a single
transportlevel connection and are not stored by caches or
forwarded by proxies
The following HTTP11 headers are hopbyhop headers
 Connection
 KeepAlive
 ProxyAuthenticate
 ProxyAuthorization
 TE
 Trailers
 TransferEncoding
 Upgrade
All other headers defined by HTTP11 are endtoend headers
Other hopbyhop headers MUST be listed in a Connection header
section 1410 to be introduced into HTTP11 or later
1352 Nonmodifiable Headers
Some features of the HTTP11 protocol such as Digest
Authentication depend on the value of certain endtoend headers A
transparent proxy SHOULD NOT modify an endtoend header unless the
definition of that header requires or specifically allows that
Fielding et al
Standards Track
Page 92
RFC 2616
HTTP11
June 1999
A transparent proxy MUST NOT modify any of the following fields in a
request or response and it MUST NOT add any of these fields if not
already present
 ContentLocation
 ContentMD5
 ETag
 LastModified
A transparent proxy MUST NOT modify any of the following fields in a
response
 Expires
but it MAY add any of these fields if not already present If an
Expires header is added it MUST be given a fieldvalue identical to
that of the Date header in that response
A
proxy MUST NOT modify or add any of the following fields in a
message that contains the notransform cachecontrol directive or in
any request
 ContentEncoding
 ContentRange
 ContentType
A nontransparent proxy MAY modify or add these fields to a message
that does not include notransform but if it does so it MUST add a
Warning 214 Transformation applied if one does not already appear
in the message see section 1446
Warning unnecessary modification of endtoend headers might
cause authentication failures if stronger authentication
mechanisms are introduced in later versions of HTTP Such
authentication mechanisms MAY rely on the values of header fields
not listed here
The ContentLength field of a request or response is added or deleted
according to the rules in section 44 A transparent proxy MUST
preserve the entitylength section 722 of the entitybody
although it MAY change the transferlength section 44
Fielding et al
Standards Track
Page 93
RFC 2616
HTTP11
June 1999
1353 Combining Headers
When a cache makes a validating request to a server and the server
provides a 304 Not Modified response or a 206 Partial Content
response the cache then constructs a response to send to the
requesting client
If the status code is 304 Not Modified the cache uses the entity
body stored in the cache entry as the entitybody of this outgoing
response If the status code is 206 Partial Content and the ETag or
LastModified headers match exactly the cache MAY combine the
contents stored in the cache entry with the new contents received in
the response and use the result as the entitybody of this outgoing
response see 1354
The endtoend headers stored in the cache entry are used for the
constructed response except that
 any stored Warning headers with warncode 1xx see section
1446 MUST be deleted from the cache entry and the forwarded
response
 any stored Warning headers with warncode 2xx MUST be retained
in the cache entry and the forwarded response
 any endtoend headers provided in the 304 or 206 response MUST
replace the corresponding headers from the cache entry
Unless the cache decides to remove the cache entry it MUST also
replace the endtoend headers stored with the cache entry with
corresponding headers received in the incoming response except for
Warning headers as described immediately above If a header field
name in the incoming response matches more than one header in the
cache entry all such old headers MUST be replaced
In other words the set of endtoend headers received in the
incoming response overrides all corresponding endtoend headers
stored with the cache entry except for stored Warning headers with
warncode 1xx which are deleted even if not overridden
Note this rule allows an origin server to use a 304 Not
Modified or a 206 Partial Content response to update any header
associated with a previous response for the same entity or sub
ranges thereof although it might not always be meaningful or
correct to do so This rule does not allow an origin server to use
a 304 Not Modified or a 206 Partial Content response to
entirely delete a header that it had provided with a previous
response
Fielding et al
Standards Track
Page 94
RFC 2616
HTTP11
June 1999
1354 Combining Byte Ranges
A response might transfer only a subrange of the bytes of an entity
body either because the request included one or more Range
specifications or because a connection was broken prematurely After
several such transfers a cache might have received several ranges of
the same entitybody
If a cache has a stored nonempty set of subranges for an entity and
an incoming response transfers another subrange the cache MAY
combine the new subrange with the existing set if both the following
conditions are met
 Both the incoming response and the cache entry have a cache
validator
 The two cache validators match using the strong comparison
function see section 1333
If either requirement is not met the cache MUST use only the most
recent partial response based on the Date values transmitted with
every response and using the incoming response if these values are
equal or missing and MUST discard the other partial information
136 Caching Negotiated Responses
Use of serverdriven content negotiation section 121 as indicated
by the presence of a Vary header field in a response alters the
conditions and procedure by which a cache can use the response for
subsequent requests See section 1444 for use of the Vary header
field by servers
A server SHOULD use the Vary header field to inform a cache of what
requestheader fields were used to select among multiple
representations of a cacheable response subject to serverdriven
negotiation The set of header fields named by the Vary field value
is known as the selecting requestheaders
When the cache receives a subsequent request whose RequestURI
specifies one or more cache entries including a Vary header field
the cache MUST NOT use such a cache entry to construct a response to
the new request unless all of the selecting requestheaders present
in the new request match the corresponding stored requestheaders in
the original request
The selecting requestheaders from two requests are defined to match
if and only if the selecting requestheaders in the first request can
be transformed to the selecting requestheaders in the second request
Fielding et al
Standards Track
Page 95
RFC 2616
HTTP11
June 1999
by adding or removing linear white space LWS at places where this
is allowed by the corresponding BNF andor combining multiple
messageheader fields with the same field name following the rules
about message headers in section 42
A Vary header fieldvalue of  always fails to match and subsequent
requests on that resource can only be properly interpreted by the
origin server
If the selecting request header fields for the cached entry do not
match the selecting request header fields of the new request then
the cache MUST NOT use a cached entry to satisfy the request unless
it first relays the new request to the origin server in a conditional
request and the server responds with 304 Not Modified including an
entity tag or ContentLocation that indicates the entity to be used
If an entity tag was assigned to a cached representation the
forwarded request SHOULD be conditional and include the entity tags
in an IfNoneMatch header field from all its cache entries for the
resource This conveys to the server the set of entities currently
held by the cache so that if any one of these entities matches the
requested entity the server can use the ETag header field in its 304
Not Modified response to tell the cache which entry is appropriate
If the entitytag of the new response matches that of an existing
entry the new response SHOULD be used to update the header fields of
the existing entry and the result MUST be returned to the client
If any of the existing cache entries contains only partial content
for the associated entity its entitytag SHOULD NOT be included in
the IfNoneMatch header field unless the request is for a range that
would be fully satisfied by that entry
If a cache receives a successful response whose ContentLocation
field matches that of an existing cache entry for the same Request
URI whose entitytag differs from that of the existing entry and
whose Date is more recent than that of the existing entry the
existing entry SHOULD NOT be returned in response to future requests
and SHOULD be deleted from the cache
137 Shared and NonShared Caches
For reasons of security and privacy it is necessary to make a
distinction between shared and nonshared caches A nonshared
cache is one that is accessible only to a single user Accessibility
in this case SHOULD be enforced by appropriate security mechanisms
All other caches are considered to be shared Other sections of
Fielding et al
Standards Track
Page 96
RFC 2616
HTTP11
June 1999
this specification place certain constraints on the operation of
shared caches in order to prevent loss of privacy or failure of
access controls
138 Errors or Incomplete Response Cache Behavior
A cache that receives an incomplete response for example with fewer
bytes of data than specified in a ContentLength header MAY store
the response However the cache MUST treat this as a partial
response Partial responses MAY be combined as described in section
1354 the result might be a full response or might still be
partial A cache MUST NOT return a partial response to a client
without explicitly marking it as such using the 206 Partial
Content status code A cache MUST NOT return a partial response
using a status code of 200 OK
If a cache receives a 5xx response while attempting to revalidate an
entry it MAY either forward this response to the requesting client
or act as if the server failed to respond In the latter case it MAY
return a previously received response unless the cached entry
includes the mustrevalidate cachecontrol directive see section
149
139 Side Effects of GET and HEAD
Unless the origin server explicitly prohibits the caching of their
responses the application of GET and HEAD methods to any resources
SHOULD NOT have side effects that would lead to erroneous behavior if
these responses are taken from a cache They MAY still have side
effects but a cache is not required to consider such side effects in
its caching decisions Caches are always expected to observe an
origin servers explicit restrictions on caching
We note one exception to this rule since some applications have
traditionally used GETs and HEADs with query URLs those containing a
 in the rel_path part to perform operations with significant side
effects caches MUST NOT treat responses to such URIs as fresh unless
the server provides an explicit expiration time This specifically
means that responses from HTTP10 servers for such URIs SHOULD NOT
be taken from a cache See section 911 for related information
1310 Invalidation After Updates or Deletions
The effect of certain methods performed on a resource at the origin
server might cause one or more existing cache entries to become non
transparently invalid That is although they might continue to be
fresh they do not accurately reflect what the origin server would
return for a new request on that resource
Fielding et al
Standards Track
Page 97
RFC 2616
HTTP11
June 1999
There is no way for the HTTP protocol to guarantee that all such
cache entries are marked invalid For example the request that
caused the change at the origin server might not have gone through
the proxy where a cache entry is stored However several rules help
reduce the likelihood of erroneous behavior
In this section the phrase invalidate an entity means that the
cache will either remove all instances of that entity from its
storage or will mark these as invalid and in need of a mandatory
revalidation before they can be returned in response to a subsequent
request
Some HTTP methods MUST cause a cache to invalidate an entity This is
either the entity referred to by the RequestURI or by the Location
or ContentLocation headers if present These methods are
 PUT
 DELETE
 POST
In order to prevent denial of service attacks an invalidation based
on the URI in a Location or ContentLocation header MUST only be
performed if the host part is the same as in the RequestURI
A cache that passes through requests for methods it does not
understand SHOULD invalidate any entities referred to by the
RequestURI
1311 WriteThrough Mandatory
All methods that might be expected to cause modifications to the
origin servers resources MUST be written through to the origin
server This currently includes all methods except for GET and HEAD
A cache MUST NOT reply to such a request from a client before having
transmitted the request to the inbound server and having received a
corresponding response from the inbound server This does not prevent
a proxy cache from sending a 100 Continue response before the
inbound server has sent its final reply
The alternative known as writeback or copyback caching is not
allowed in HTTP11 due to the difficulty of providing consistent
updates and the problems arising from server cache or network
failure prior to writeback
Fielding et al
Standards Track
Page 98
RFC 2616
HTTP11
June 1999
1312 Cache Replacement
If a new cacheable see sections 1492 1325 1326 and 138
response is received from a resource while any existing responses for
the same resource are cached the cache SHOULD use the new response
to reply to the current request It MAY insert it into cache storage
and MAY if it meets all other requirements use it to respond to any
future requests that would previously have caused the old response to
be returned If it inserts the new response into cache storage
the
rules in section 1353 apply
Note a new response that has an older Date header value than
existing cached responses is not cacheable
1313 History Lists
User agents often have history mechanisms such as Back buttons and
history lists which can be used to redisplay an entity retrieved
earlier in a session
History mechanisms and caches are different In particular history
mechanisms SHOULD NOT try to show a semantically transparent view of
the current state of a resource Rather a history mechanism is meant
to show exactly what the user saw at the time when the resource was
retrieved
By default an expiration time does not apply to history mechanisms
If the entity is still in storage a history mechanism SHOULD display
it even if the entity has expired unless the user has specifically
configured the agent to refresh expired history documents
This is not to be construed to prohibit the history mechanism from
telling the user that a view might be stale
Note if history list mechanisms unnecessarily prevent users from
viewing stale resources this will tend to force service authors
to avoid using HTTP expiration controls and cache controls when
they would otherwise like to Service authors may consider it
important that users not be presented with error messages or
warning messages when they use navigation controls such as BACK
to view previously fetched resources Even though sometimes such
resources ought not to cached or ought to expire quickly user
interface considerations may force service authors to resort to
other means of preventing caching eg onceonly URLs in order
not to suffer the effects of improperly functioning history
mechanisms
Fielding et al
Standards Track
Page 99
RFC 2616
HTTP11
June 1999
14 Header Field Definitions
This section defines the syntax and semantics of all standard
HTTP11 header fields For entityheader fields both sender and
recipient refer to either the client or the server depending on who
sends and who receives the entity
141 Accept
The Accept requestheader field can be used to specify certain media
types which are acceptable for the response Accept headers can be
used to indicate that the request is specifically limited to a small
set of desired types as in the case of a request for an inline
image
Accept
 Accept
 mediarange  acceptparams
mediarange

  type
  type  subtype
   parameter
acceptparams
  q  qvalue  acceptextension
acceptextension   token    token  quotedstring
The asterisk  character is used to group media types into ranges
with  indicating all media types and type indicating all
subtypes of that type The mediarange MAY include media type
parameters that are applicable to that range
Each mediarange MAY be followed by one or more acceptparams
beginning with the q parameter for indicating a relative quality
factor The first q parameter if any separates the mediarange
parameters from the acceptparams Quality factors allow the user
or user agent to indicate the relative degree of preference for that
mediarange using the qvalue scale from 0 to 1 section 39 The
default value is q1
Note Use of the q parameter name to separate media type
parameters from Accept extension parameters is due to historical
practice Although this prevents any media type parameter named
q from being used with a media range such an event is believed
to be unlikely given the lack of any q parameters in the IANA
media type registry and the rare usage of any media type
parameters in Accept Future media types are discouraged from
registering any parameter named q
Fielding et al
Standards Track
Page 100
RFC 2616
HTTP11
June 1999
The example
Accept audio q02 audiobasic
SHOULD be interpreted as I prefer audiobasic but send me any audio
type if it is the best available after an 80% markdown in quality
If no Accept header field is present then it is assumed that the
client accepts all media types If an Accept header field is present
and if the server cannot send a response which is acceptable
according to the combined Accept field value then the server SHOULD
send a 406 not acceptable response
A more elaborate example is
Accept textplain q05 texthtml
textxdvi q08 textxc
Verbally this would be interpreted as texthtml and textxc are
the preferred media types but if they do not exist then send the
textxdvi entity and if that does not exist send the textplain
entity
Media ranges can be overridden by more specific media ranges or
specific media types If more than one media range applies to a given
type the most specific reference has precedence For example
Accept text texthtml texthtmllevel1
have the following precedence
1 texthtmllevel1
2 texthtml
3 text
4
The media type quality factor associated with a given type is
determined by finding the media range with the highest precedence
which matches that type For example
Accept textq03 texthtmlq07 texthtmllevel1
texthtmllevel2q04 q05
would cause the following values to be associated
texthtmllevel1
 1
texthtml
 07
textplain
 03
Fielding et al
Standards Track
Page 101
RFC 2616
HTTP11
June 1999
imagejpeg
 05
texthtmllevel2
 04
texthtmllevel3
 07
Note A user agent might be provided with a default set of quality
values for certain media ranges However unless the user agent is
a closed system which cannot interact with other rendering agents
this default set ought to be configurable by the user
142 AcceptCharset
The AcceptCharset requestheader field can be used to indicate what
character sets are acceptable for the response This field allows
clients capable of understanding more comprehensive or special
purpose character sets to signal that capability to a server which is
capable of representing documents in those character sets
AcceptCharset  AcceptCharset
1  charset     q  qvalue
Character set values are described in section 34 Each charset MAY
be given an associated quality value which represents the users
preference for that charset The default value is q1 An example is
AcceptCharset iso88595 unicode11q08
The special value  if present in the AcceptCharset field
matches every character set including ISO88591 which is not
mentioned elsewhere in the AcceptCharset field If no  is present
in an AcceptCharset field then all character sets not explicitly
mentioned get a quality value of 0 except for ISO88591 which gets
a quality value of 1 if not explicitly mentioned
If no AcceptCharset header is present the default is that any
character set is acceptable If an AcceptCharset header is present
and if the server cannot send a response which is acceptable
according to the AcceptCharset header then the server SHOULD send
an error response with the 406 not acceptable status code though
the sending of an unacceptable response is also allowed
143 AcceptEncoding
The AcceptEncoding requestheader field is similar to Accept but
restricts the contentcodings section 35 that are acceptable in
the response
AcceptEncoding
 AcceptEncoding
Fielding et al
Standards Track
Page 102
RFC 2616
HTTP11
June 1999
1 codings   q  qvalue
codings
  contentcoding
Examples of its use are
AcceptEncoding compress gzip
AcceptEncoding
AcceptEncoding
AcceptEncoding compressq05 gzipq10
AcceptEncoding gzipq10 identity q05 q0
A server tests whether a contentcoding is acceptable according to
an AcceptEncoding field using these rules
1 If the contentcoding is one of the contentcodings listed in
the AcceptEncoding field then it is acceptable unless it is
accompanied by a qvalue of 0 As defined in section 39 a
qvalue of 0 means not acceptable
2 The special  symbol in an AcceptEncoding field matches any
available contentcoding not explicitly listed in the header
field
3 If multiple contentcodings are acceptable then the acceptable
contentcoding with the highest nonzero qvalue is preferred
4 The identity contentcoding is always acceptable unless
specifically refused because the AcceptEncoding field includes
identityq0 or because the field includes q0 and does
not explicitly include the identity contentcoding If the
AcceptEncoding fieldvalue is empty then only the identity
encoding is acceptable
If an AcceptEncoding field is present in a request and if the
server cannot send a response which is acceptable according to the
AcceptEncoding header then the server SHOULD send an error response
with the 406 Not Acceptable status code
If no AcceptEncoding field is present in a request the server MAY
assume that the client will accept any content coding In this case
if identity is one of the available contentcodings then the
server SHOULD use the identity contentcoding unless it has
additional information that a different contentcoding is meaningful
to the client
Note If the request does not include an AcceptEncoding field
and if the identity contentcoding is unavailable then
contentcodings commonly understood by HTTP10 clients ie
Fielding et al
Standards Track
Page 103
RFC 2616
HTTP11
June 1999
gzip and compress are preferred some older clients
improperly display messages sent with other contentcodings
The
server might also make this decision based on information about
the particular useragent or client
Note Most HTTP10 applications do not recognize or obey qvalues
associated with contentcodings This means that qvalues will not
work and are not permitted with xgzip or xcompress
144 AcceptLanguage
The AcceptLanguage requestheader field is similar to Accept but
restricts the set of natural languages that are preferred as a
response to the request Language tags are defined in section 310
AcceptLanguage  AcceptLanguage
1 languagerange   q  qvalue
languagerange
   18ALPHA   18ALPHA
Each languagerange MAY be given an associated quality value which
represents an estimate of the users preference for the languages
specified by that range The quality value defaults to q1 For
example
AcceptLanguage da engbq08 enq07
would mean I prefer Danish but will accept British English and
other types of English A languagerange matches a languagetag if
it exactly equals the tag or if it exactly equals a prefix of the
tag such that the first tag character following the prefix is
The special range  if present in the AcceptLanguage field
matches every tag not matched by any other range present in the
AcceptLanguage field
Note This use of a prefix matching rule does not imply that
language tags are assigned to languages in such a way that it is
always true that if a user understands a language with a certain
tag then this user will also understand all languages with tags
for which this tag is a prefix The prefix rule simply allows the
use of prefix tags if this is the case
The language quality factor assigned to a languagetag by the
AcceptLanguage field is the quality value of the longest language
range in the field that matches the languagetag If no language
range in the field matches the tag the language quality factor
assigned is 0 If no AcceptLanguage header is present in the
request the server
Fielding et al
Standards Track
Page 104
RFC 2616
HTTP11
June 1999
SHOULD assume that all languages are equally acceptable If an
AcceptLanguage header is present then all languages which are
assigned a quality factor greater than 0 are acceptable
It might be contrary to the privacy expectations of the user to send
an AcceptLanguage header with the complete linguistic preferences of
the user in every request For a discussion of this issue see
section 1514
As intelligibility is highly dependent on the individual user it is
recommended that client applications make the choice of linguistic
preference available to the user If the choice is not made
available then the AcceptLanguage header field MUST NOT be given in
the request
Note When making the choice of linguistic preference available to
the user we remind implementors of
the fact that users are not
familiar with the details of language matching as described above
and should provide appropriate guidance As an example users
might assume that on selecting engb they will be served any
kind of English document if British English is not available A
user agent might suggest in such a case to add en to get the
best matching behavior
145 AcceptRanges
The AcceptRanges responseheader field allows the server to
indicate its acceptance of range requests for a resource
AcceptRanges
 AcceptRanges  acceptableranges
acceptableranges  1rangeunit  none
Origin servers that accept byterange requests MAY send
AcceptRanges bytes
but are not required to do so Clients MAY generate byterange
requests without having received this header for the resource
involved Range units are defined in section 312
Servers that do not accept any kind of range request for a
resource MAY send
AcceptRanges none
to advise the client not to attempt a range request
Fielding et al
Standards Track
Page 105
RFC 2616
HTTP11
June 1999
146 Age
The Age responseheader field conveys the senders estimate of the
amount of time since the response or its revalidation was
generated at the origin server A cached response is fresh if
its age does not exceed its freshness lifetime Age values are
calculated as specified in section 1323
Age  Age  agevalue
agevalue  deltaseconds
Age values are nonnegative decimal integers representing time in
seconds
If a cache receives a value larger than the largest positive
integer it can represent or if any of its age calculations
overflows it MUST transmit an Age header with a value of
2147483648 2^31 An HTTP11 server that includes a cache MUST
include an Age header field in every response generated from its
own cache Caches SHOULD use an arithmetic type of at least 31
bits of range
147 Allow
The Allow entityheader field lists the set of methods supported
by the resource identified by the RequestURI The purpose of this
field is strictly to inform the recipient of valid methods
associated with the resource An Allow header field MUST be
present in a 405 Method Not Allowed response
Allow
 Allow  Method
Example of use
Allow GET HEAD PUT
This field cannot prevent a client from trying other methods
However the indications given by the Allow header field value
SHOULD be followed The actual set of allowed methods is defined
by the origin server at the time of each request
The Allow header field MAY be provided with a PUT request to
recommend the methods to be supported by the new or modified
resource The server is not required to support these methods and
SHOULD include an Allow header in the response giving the actual
supported methods
Fielding et al
Standards Track
Page 106
RFC 2616
HTTP11
June 1999
A proxy MUST NOT modify the Allow header field even if it does not
understand all the methods specified since the user agent might
have other means of communicating with the origin server
148 Authorization
A user agent that wishes to authenticate itself with a server
usually but not necessarily after receiving a 401 responsedoes
so by including an Authorization requestheader field with the
request
The Authorization field value consists of credentials
containing the authentication information of the user agent for
the realm of the resource being requested
Authorization
 Authorization  credentials
HTTP access authentication is described in HTTP Authentication
Basic and Digest Access Authentication 43 If a request is
authenticated and a realm specified the same credentials SHOULD
be valid for all other requests within this realm assuming that
the authentication scheme itself does not require otherwise such
as credentials that vary according to a challenge value or using
synchronized clocks
When a shared cache see section 137 receives a request
containing an Authorization field it MUST NOT return the
corresponding response as a reply to any other request unless one
of the following specific exceptions holds
1 If the response includes the smaxage cachecontrol
directive the cache MAY use that response in replying to a
subsequent request But if the specified maximum age has
passed a proxy cache MUST first revalidate it with the origin
server using the requestheaders from the new request to allow
the origin server to authenticate the new request This is the
defined behavior for smaxage If the response includes s
maxage0 the proxy MUST always revalidate it before reusing
it
2 If the response includes the mustrevalidate cachecontrol
directive the cache MAY use that response in replying to a
subsequent request But if the response is stale all caches
MUST first revalidate it with the origin server using the
requestheaders from the new request to allow the origin server
to authenticate the new request
3 If the response includes the public cachecontrol directive
it MAY be returned in reply to any subsequent request
Fielding et al
Standards Track
Page 107
RFC 2616
HTTP11
June 1999
149 CacheControl
The CacheControl generalheader field is used to specify directives
that MUST be obeyed by all caching mechanisms along the
requestresponse chain The directives specify behavior intended to
prevent caches from adversely interfering with the request or
response These directives typically override the default caching
algorithms Cache directives are unidirectional in that the presence
of a directive in a request does not imply that the same directive is
to be given in the response
Note that HTTP10 caches might not implement CacheControl and
might only implement Pragma nocache see section 1432
Cache directives MUST be passed through by a proxy or gateway
application regardless of their significance to that application
since the directives might be applicable to all recipients along the
requestresponse chain It is not possible to specify a cache
directive for a specific cache
CacheControl
 CacheControl  1cachedirective
cachedirective  cacherequestdirective
 cacheresponsedirective
cacherequestdirective
nocache
 Section 1491
 nostore
 Section 1492
 maxage  deltaseconds
 Section 1493 1494
 maxstale   deltaseconds
 Section 1493
 minfresh  deltaseconds
 Section 1493
 notransform
 Section 1495
 onlyifcached
 Section 1494
 cacheextension
 Section 1496
cacheresponsedirective
public
 Section 1491
 private    1fieldname    Section 1491
 nocache    1fieldname   Section 1491
 nostore
 Section 1492
 notransform
 Section 1495
 mustrevalidate
 Section 1494
 proxyrevalidate
 Section 1494
 maxage  deltaseconds
 Section 1493
 smaxage  deltaseconds
 Section 1493
 cacheextension
 Section 1496
cacheextension  token    token  quotedstring
Fielding et al
Standards Track
Page 108
RFC 2616
HTTP11
June 1999
When a directive appears without any 1fieldname parameter the
directive applies to the entire request or response When such a
directive appears with a 1fieldname parameter it applies only to
the named field or fields and not to the rest of the request or
response This mechanism supports extensibility implementations of
future versions of the HTTP protocol might apply these directives to
header fields not defined in HTTP11
The cachecontrol directives can be broken down into these general
categories
 Restrictions on what are cacheable these may only be imposed by
the origin server
 Restrictions on what may be stored by a cache these may be
imposed by either the origin server or the user agent
 Modifications of the basic expiration mechanism these may be
imposed by either the origin server or the user agent
 Controls over cache revalidation and reload these may only be
imposed by a user agent
 Control over transformation of entities
 Extensions to the caching system
1491 What is Cacheable
By default a response is cacheable if the requirements of the
request method request header fields and the response status
indicate that it is cacheable Section 134 summarizes these defaults
for cacheability The following CacheControl response directives
allow an origin server to override the default cacheability of a
response
public
Indicates that the response MAY be cached by any cache even if it
would normally be noncacheable or cacheable only within a non
shared cache See also Authorization section 148 for
additional details
private
Indicates that all or part of the response message is intended for
a single user and MUST NOT be cached by a shared cache This
allows an origin server to state that the specified parts of the
Fielding et al
Standards Track
Page 109
RFC 2616
HTTP11
June 1999
response are intended for only one user and are not a valid
response for requests by other users A private nonshared cache
MAY cache the response
Note This usage of the word private only controls where the
response may be cached and cannot ensure the privacy of the
message content
nocache
If the nocache directive does not specify a fieldname then a
cache MUST NOT use the response to satisfy a subsequent request
without successful revalidation with the origin server This
allows an origin server to prevent caching even by caches that
have been configured to return stale responses to client requests
If the nocache directive does specify one or more fieldnames
then a cache MAY use the response to satisfy a subsequent request
subject to any other restrictions on caching However the
specified fieldnames MUST NOT be sent in the response to a
subsequent request without successful revalidation with the origin
server This allows an origin server to prevent the reuse of
certain header fields in a response while still allowing caching
of the rest of the response
Note Most HTTP10 caches will not recognize or obey this
directive
1492 What May be Stored by Caches
nostore
The purpose of the nostore directive is to prevent the
inadvertent release or retention of sensitive information for
example on backup tapes The nostore directive applies to the
entire message and MAY be sent either in a response or in a
request If sent in a request a cache MUST NOT store any part of
either this request or any response to it If sent in a response
a cache MUST NOT store any part of either this response or the
request that elicited it This directive applies to both non
shared and shared caches MUST NOT store in this context means
that the cache MUST NOT intentionally store the information in
nonvolatile storage and MUST make a besteffort attempt to
remove the information from volatile storage as promptly as
possible after forwarding it
Even when this directive is associated with a response users
might explicitly store such a response outside of the caching
system eg with a Save As dialog History buffers MAY store
such responses as part of their normal operation
Fielding et al
Standards Track
Page 110
RFC 2616
HTTP11
June 1999
The purpose of this directive is to meet the stated requirements
of certain users and service authors who are concerned about
accidental releases of information via unanticipated accesses to
cache data structures While the use of this directive might
improve privacy in some cases we caution that it is NOT in any
way a reliable or sufficient mechanism for ensuring privacy In
particular malicious or compromised caches might not recognize or
obey this directive and communications networks might be
vulnerable to eavesdropping
1493 Modifications of the Basic Expiration Mechanism
The expiration time of an entity MAY be specified by the origin
server using the Expires header see section 1421 Alternatively
it MAY be specified using the maxage directive in a response When
the maxage cachecontrol directive is present in a cached response
the response is stale if its current age is greater than the age
value given in seconds at the time of a new request for that
resource The maxage directive on a response implies that the
response is cacheable ie public unless some other more
restrictive cache directive is also present
If a response includes both an Expires header and a maxage
directive the maxage directive overrides the Expires header even
if the Expires header is more restrictive This rule allows an origin
server to provide for a given response a longer expiration time to
an HTTP11 or later cache than to an HTTP10 cache This might be
useful if certain HTTP10 caches improperly calculate ages or
expiration times perhaps due to desynchronized clocks
Many HTTP10 cache implementations will treat an Expires value that
is less than or equal to the response Date value as being equivalent
to the CacheControl response directive nocache If an HTTP11
cache receives such a response and the response does not include a
CacheControl header field it SHOULD consider the response to be
noncacheable in order to retain compatibility with HTTP10 servers
Note An origin server might wish to use a relatively new HTTP
cache control feature such as the private directive on a
network including older caches that do not understand that
feature The origin server will need to combine the new feature
with an Expires field whose value is less than or equal to the
Date value This will prevent older caches from improperly
caching the response
Fielding et al
Standards Track
Page 111
RFC 2616
HTTP11
June 1999
smaxage
If a response includes an smaxage directive then for a shared
cache but not for a private cache the maximum age specified by
this directive overrides the maximum age specified by either the
maxage directive or the Expires header The smaxage directive
also implies the semantics of the proxyrevalidate directive see
section 1494 ie that the shared cache must not use the
entry after it becomes stale to respond to a subsequent request
without first revalidating it with the origin server The s
maxage directive is always ignored by a private cache
Note that most older caches not compliant with this specification
do not implement any cachecontrol directives An origin server
wishing to use a cachecontrol directive that restricts but does not
prevent caching by an HTTP11compliant cache MAY exploit the
requirement that the maxage directive overrides the Expires header
and the fact that preHTTP11compliant caches do not observe the
maxage directive
Other directives allow a user agent to modify the basic expiration
mechanism These directives MAY be specified on a request
maxage
Indicates that the client is willing to accept a response whose
age is no greater than the specified time in seconds Unless max
stale directive is also included the client is not willing to
accept a stale response
minfresh
Indicates that the client is willing to accept a response whose
freshness lifetime is no less than its current age plus the
specified time in seconds That is the client wants a response
that will still be fresh for at least the specified number of
seconds
maxstale
Indicates that the client is willing to accept a response that has
exceeded its expiration time If maxstale is assigned a value
then the client is willing to accept a response that has exceeded
its expiration time by no more than the specified number of
seconds If no value is assigned to maxstale then the client is
willing to accept a stale response of any age
If a cache returns a stale response either because of a maxstale
directive on a request or because the cache is configured to
override the expiration time of a response the cache MUST attach a
Warning header to the stale response using Warning 110 Response is
stale
Fielding et al
Standards Track
Page 112
RFC 2616
HTTP11
June 1999
A cache MAY be configured to return stale responses without
validation but only if this does not conflict with any MUSTlevel
requirements concerning cache validation eg a mustrevalidate
cachecontrol directive
If both the new request and the cached entry include maxage
directives then the lesser of the two values is used for determining
the freshness of the cached entry for that request
1494 Cache Revalidation and Reload Controls
Sometimes a user agent might want or need to insist that a cache
revalidate its cache entry with the origin server and not just with
the next cache along the path to the origin server or to reload its
cache entry from the origin server Endtoend revalidation might be
necessary if either the cache or the origin server has overestimated
the expiration time of the cached response Endtoend reload may be
necessary if the cache entry has become corrupted for some reason
Endtoend revalidation may be requested either when the client does
not have its own local cached copy in which case we call it
unspecified endtoend revalidation or when the client does have a
local cached copy in which case we call it specific endtoend
revalidation
The client can specify these three kinds of action using Cache
Control request directives
Endtoend reload
The request includes a nocache cachecontrol directive or for
compatibility with HTTP10 clients Pragma nocache Field
names MUST NOT be included with the nocache directive in a
request The server MUST NOT use a cached copy when responding to
such a request
Specific endtoend revalidation
The request includes a maxage0 cachecontrol directive which
forces each cache along the path to the origin server to
revalidate its own entry if any with the next cache or server
The initial request includes a cachevalidating conditional with
the clients current validator
Unspecified endtoend revalidation
The request includes maxage0 cachecontrol directive which
forces each cache along the path to the origin server to
revalidate its own entry if any with the next cache or server
The initial request does not include a cachevalidating
Fielding et al
Standards Track
Page 113
RFC 2616
HTTP11
June 1999
conditional the first cache along the path if any that holds a
cache entry for this resource includes a cachevalidating
conditional with its current validator
maxage
When an intermediate cache is forced by means of a maxage0
directive to revalidate its own cache entry and the client has
supplied its own validator in the request the supplied validator
might differ from the validator currently stored with the cache
entry In this case the cache MAY use either validator in making
its own request without affecting semantic transparency
However the choice of validator might affect performance The
best approach is for the intermediate cache to use its own
validator when making its request If the server replies with 304
Not Modified then the cache can return its now validated copy
to the client with a 200 OK response If the server replies with
a new entity and cache validator however the intermediate cache
can compare the returned validator with the one provided in the
clients request using the strong comparison function If the
clients validator is equal to the origin servers then the
intermediate cache simply returns 304 Not Modified Otherwise
it returns the new entity with a 200 OK response
If a request includes the nocache directive it SHOULD NOT
include minfresh maxstale or maxage
onlyifcached
In some cases such as times of extremely poor network
connectivity a client may want a cache to return only those
responses that it currently has stored and not to reload or
revalidate with the origin server To do this the client may
include the onlyifcached directive in a request If it receives
this directive a cache SHOULD either respond using a cached entry
that is consistent with the other constraints of the request or
respond with a 504 Gateway Timeout status However if a group
of caches is being operated as a unified system with good internal
connectivity such a request MAY be forwarded within that group of
caches
mustrevalidate
Because a cache MAY be configured to ignore a servers specified
expiration time and because a client request MAY include a max
stale directive which has a similar effect the protocol also
includes a mechanism for the origin server to require revalidation
of a cache entry on any subsequent use When the mustrevalidate
directive is present in a response received by a cache that cache
MUST NOT use the entry after it becomes stale to respond to a
Fielding et al
Standards Track
Page 114
RFC 2616
HTTP11
June 1999
subsequent request without first revalidating it with the origin
server Ie the cache MUST do an endtoend revalidation every
time if based solely on the origin servers Expires or maxage
value the cached response is stale
The mustrevalidate directive is necessary to support reliable
operation for certain protocol features In all circumstances an
HTTP11 cache MUST obey the mustrevalidate directive in
particular if the cache cannot reach the origin server for any
reason it MUST generate a 504 Gateway Timeout response
Servers SHOULD send the mustrevalidate directive if and only if
failure to revalidate a request on the entity could result in
incorrect operation such as a silently unexecuted financial
transaction Recipients MUST NOT take any automated action that
violates this directive and MUST NOT automatically provide an
unvalidated copy of the entity if revalidation fails
Although this is not recommended user agents operating under
severe connectivity constraints MAY violate this directive but if
so MUST explicitly warn the user that an unvalidated response has
been provided The warning MUST be provided on each unvalidated
access and SHOULD require explicit user confirmation
proxyrevalidate
The proxyrevalidate directive has the same meaning as the must
revalidate directive except that it does not apply to nonshared
user agent caches It can be used on a response to an
authenticated request to permit the users cache to store and
later return the response without needing to revalidate it since
it has already been authenticated once by that user while still
requiring proxies that service many users to revalidate each time
in order to make sure that each user has been authenticated
Note that such authenticated responses also need the public cache
control directive in order to allow them to be cached at all
1495 NoTransform Directive
notransform
Implementors of intermediate caches proxies have found it useful
to convert the media type of certain entity bodies A non
transparent proxy might for example convert between image
formats in order to save cache space or to reduce the amount of
traffic on a slow link
Serious operational problems occur however when these
transformations are applied to entity bodies intended for certain
kinds of applications For example applications for medical
Fielding et al
Standards Track
Page 115
RFC 2616
HTTP11
June 1999
imaging scientific data analysis and those using endtoend
authentication all depend on receiving an entity body that is bit
for bit identical to the original entitybody
Therefore if a message includes the notransform directive an
intermediate cache or proxy MUST NOT change those headers that are
listed in section 1352 as being subject to the notransform
directive This implies that the cache or proxy MUST NOT change
any aspect of the entitybody that is specified by these headers
including the value of the entitybody itself
1496 Cache Control Extensions
The CacheControl header field can be extended through the use of one
or more cacheextension tokens each with an optional assigned value
Informational extensions those which do not require a change in
cache behavior MAY be added without changing the semantics of other
directives Behavioral extensions are designed to work by acting as
modifiers to the existing base of cache directives Both the new
directive and the standard directive are supplied such that
applications which do not understand the new directive will default
to the behavior specified by the standard directive and those that
understand the new directive will recognize it as modifying the
requirements associated with the standard directive In this way
extensions to the cachecontrol directives can be made without
requiring changes to the base protocol
This extension mechanism depends on an HTTP cache obeying all of the
cachecontrol directives defined for its native HTTPversion obeying
certain extensions and ignoring all directives that it does not
understand
For example consider a hypothetical new response directive called
community which acts as a modifier to the private directive We
define this new directive to mean that in addition to any nonshared
cache any cache which is shared only by members of the community
named within its value may cache the response An origin server
wishing to allow the UCI community to use an otherwise private
response in their shared caches could do so by including
CacheControl private communityUCI
A cache seeing this header field will act correctly even if the cache
does not understand the community cacheextension since it will also
see and understand the private directive and thus default to the safe
behavior
Fielding et al
Standards Track
Page 116
RFC 2616
HTTP11
June 1999
Unrecognized cachedirectives MUST be ignored it is assumed that any
cachedirective likely to be unrecognized by an HTTP11 cache will
be combined with standard directives or the responses default
cacheability such that the cache behavior will remain minimally
correct even if the cache does not understand the extensions
1410 Connection
The Connection generalheader field allows the sender to specify
options that are desired for that particular connection and MUST NOT
be communicated by proxies over further connections
The Connection header has the following grammar
Connection  Connection  1connectiontoken
connectiontoken
 token
HTTP11 proxies MUST parse the Connection header field before a
message is forwarded and for each connectiontoken in this field
remove any header fields from the message with the same name as the
connectiontoken Connection options are signaled by the presence of
a connectiontoken in the Connection header field not by any
corresponding additional header fields since the additional header
field may not be sent if there are no parameters associated with that
connection option
Message headers listed in the Connection header MUST NOT include
endtoend headers such as CacheControl
HTTP11 defines the close connection option for the sender to
signal that the connection will be closed after completion of the
response For example
Connection close
in either the request or the response header fields indicates that
the connection SHOULD NOT be considered persistent section 81
after the current requestresponse is complete
HTTP11 applications that do not support persistent connections MUST
include the close connection option in every message
A system receiving an HTTP10 or lowerversion message that
includes a Connection header MUST for each connectiontoken in this
field remove and ignore any header fields from the message with
the same name as the connectiontoken This protects against mistaken
forwarding of such header fields by preHTTP11 proxies See section
1962
Fielding et al
Standards Track
Page 117
RFC 2616
HTTP11
June 1999
1411 ContentEncoding
The ContentEncoding entityheader field is used as a modifier to the
mediatype When present its value indicates what additional content
codings have been applied to the entitybody and thus what decoding
mechanisms must be applied in order to obtain the mediatype
referenced by the ContentType header field ContentEncoding is
primarily used to allow a document to be compressed without losing
the identity of its underlying media type
ContentEncoding
 ContentEncoding  1contentcoding
Content codings are defined in section 35 An example of its use is
ContentEncoding gzip
The contentcoding is a characteristic of the entity identified by
the RequestURI Typically the entitybody is stored with this
encoding and is only decoded before rendering or analogous usage
However a nontransparent proxy MAY modify the contentcoding if the
new coding is known to be acceptable to the recipient unless the
notransform cachecontrol directive is present in the message
If the contentcoding of an entity is not identity then the
response MUST include a ContentEncoding entityheader section
1411 that lists the nonidentity contentcodings used
If the contentcoding of an entity in a request message is not
acceptable to the origin server the server SHOULD respond with a
status code of 415 Unsupported Media Type
If multiple encodings have been applied to an entity the content
codings MUST be listed in the order in which they were applied
Additional information about the encoding parameters MAY be provided
by other entityheader fields not defined by this specification
1412 ContentLanguage
The ContentLanguage entityheader field describes the natural
languages of the intended audience for the enclosed entity Note
that this might not be equivalent to all the languages used within
the entitybody
ContentLanguage
 ContentLanguage  1languagetag
Fielding et al
Standards Track
Page 118
RFC 2616
HTTP11
June 1999
Language tags are defined in section 310 The primary purpose of
ContentLanguage is to allow a user to identify and differentiate
entities according to the users own preferred language Thus if the
body content is intended only for a Danishliterate audience the
appropriate field is
ContentLanguage da
If no ContentLanguage is specified the default is that the content
is intended for all language audiences This might mean that the
sender does not consider it to be specific to any natural language
or that the sender does not know for which language it is intended
Multiple languages MAY be listed for content that is intended for
multiple audiences For example a rendition of the Treaty of
Waitangi presented simultaneously in the original Maori and English
versions would call for
ContentLanguage mi en
However just because multiple languages are present within an entity
does not mean that it is intended for multiple linguistic audiences
An example would be a beginners language primer such as A First
Lesson in Latin which is clearly intended to be used by an
Englishliterate audience In this case the ContentLanguage would
properly only include en
ContentLanguage MAY be applied to any media type  it is not
limited to textual documents
1413 ContentLength
The ContentLength entityheader field indicates the size of the
entitybody in decimal number of OCTETs sent to the recipient or
in the case of the HEAD method the size of the entitybody that
would have been sent had the request been a GET
ContentLength
 ContentLength  1DIGIT
An example is
ContentLength 3495
Applications SHOULD use this field to indicate the transferlength of
the messagebody unless this is prohibited by the rules in section
44
Fielding et al
Standards Track
Page 119
RFC 2616
HTTP11
June 1999
Any ContentLength greater than or equal to zero is a valid value
Section 44 describes how to determine the length of a messagebody
if a ContentLength is not given
Note that the meaning of this field is significantly different from
the corresponding definition in MIME where it is an optional field
used within the messageexternalbody contenttype In HTTP it
SHOULD be sent whenever the messages length can be determined prior
to being transferred unless this is prohibited by the rules in
section 44
1414 ContentLocation
The ContentLocation entityheader field MAY be used to supply the
resource location for the entity enclosed in the message when that
entity is accessible from a location separate from the requested
resources URI A server SHOULD provide a ContentLocation for the
variant corresponding to the response entity especially in the case
where a resource has multiple entities associated with it and those
entities actually have separate locations by which they might be
individually accessed the server SHOULD provide a ContentLocation
for the particular variant which is returned
ContentLocation  ContentLocation
 absoluteURI  relativeURI
The value of ContentLocation also defines the base URI for the
entity
The ContentLocation value is not a replacement for the original
requested URI it is only a statement of the location of the resource
corresponding to this particular entity at the time of the request
Future requests MAY specify the ContentLocation URI as the request
URI if the desire is to identify the source of that particular
entity
A cache cannot assume that an entity with a ContentLocation
different from the URI used to retrieve it can be used to respond to
later requests on that ContentLocation URI However the Content
Location can be used to differentiate between multiple entities
retrieved from a single requested resource as described in section
136
If the ContentLocation is a relative URI the relative URI is
interpreted relative to the RequestURI
The meaning of the ContentLocation header in PUT or POST requests is
undefined servers are free to ignore it in those cases
Fielding et al
Standards Track
Page 120
RFC 2616
HTTP11
June 1999
1415 ContentMD5
The ContentMD5 entityheader field as defined in RFC 1864 23 is
an MD5 digest of the entitybody for the purpose of providing an
endtoend message integrity check MIC of the entitybody Note a
MIC is good for detecting accidental modification of the entitybody
in transit but is not proof against malicious attacks
ContentMD5
 ContentMD5  md5digest
md5digest
 base64 of 128 bit MD5 digest as per RFC 1864
The ContentMD5 header field MAY be generated by an origin server or
client to function as an integrity check of the entitybody Only
origin servers or clients MAY generate the ContentMD5 header field
proxies and gateways MUST NOT generate it as this would defeat its
value as an endtoend integrity check Any recipient of the entity
body including gateways and proxies MAY check that the digest value
in this header field matches that of the entitybody as received
The MD5 digest is computed based on the content of the entitybody
including any contentcoding that has been applied but not including
any transferencoding applied to the messagebody If the message is
received with a transferencoding that encoding MUST be removed
prior to checking the ContentMD5 value against the received entity
This has the result that the digest is computed on the octets of the
entitybody exactly as and in the order that they would be sent if
no transferencoding were being applied
HTTP extends RFC 1864 to permit the digest to be computed for MIME
composite mediatypes eg multipart and messagerfc822 but
this does not change how the digest is computed as defined in the
preceding paragraph
There are several consequences of this The entitybody for composite
types MAY contain many bodyparts each with its own MIME and HTTP
headers including ContentMD5 ContentTransferEncoding and
ContentEncoding headers If a bodypart has a ContentTransfer
Encoding or ContentEncoding header it is assumed that the content
of the bodypart has had the encoding applied and the bodypart is
included in the ContentMD5 digest as is  ie after the
application The TransferEncoding header field is not allowed within
bodyparts
Conversion of all line breaks to CRLF MUST NOT be done before
computing or checking the digest the line break convention used in
the text actually transmitted MUST be left unaltered when computing
the digest
Fielding et al
Standards Track
Page 121
RFC 2616
HTTP11
June 1999
Note while the definition of ContentMD5 is exactly the same for
HTTP as in RFC 1864 for MIME entitybodies there are several ways
in which the application of ContentMD5 to HTTP entitybodies
differs from its application to MIME entitybodies One is that
HTTP unlike MIME does not use ContentTransferEncoding and
does use TransferEncoding and ContentEncoding Another is that
HTTP more frequently uses binary content types than MIME so it is
worth noting that in such cases the byte order used to compute
the digest is the transmission byte order defined for the type
Lastly HTTP allows transmission of text types with any of several
line break conventions and not just the canonical form using CRLF
1416 ContentRange
The ContentRange entityheader is sent with a partial entitybody to
specify where in the full entitybody the partial body should be
applied Range units are defined in section 312
ContentRange  ContentRange  contentrangespec
contentrangespec
 bytecontentrangespec
bytecontentrangespec  bytesunit SP
byterangerespspec
 instancelength
byterangerespspec  firstbytepos  lastbytepos

instancelength
 1DIGIT
The header SHOULD indicate the total length of the full entitybody
unless this length is unknown or difficult to determine The asterisk
 character means that the instancelength is unknown at the time
when the response was generated
Unlike byterangesspecifier values see section 14351 a byte
rangerespspec MUST only specify one range and MUST contain
absolute byte positions for both the first and last byte of the
range
A bytecontentrangespec with a byterangerespspec whose last
bytepos value is less than its firstbytepos value or whose
instancelength value is less than or equal to its lastbytepos
value is invalid The recipient of an invalid bytecontentrange
spec MUST ignore it and any content transferred along with it
A server sending a response with status code 416 Requested range not
satisfiable SHOULD include a ContentRange field with a byterange
respspec of  The instancelength specifies the current length of
Fielding et al
Standards Track
Page 122
RFC 2616
HTTP11
June 1999
the selected resource A response with status code 206 Partial
Content MUST NOT include a ContentRange field with a byterange
respspec of
Examples of bytecontentrangespec values assuming that the entity
contains a total of 1234 bytes
 The first 500 bytes
bytes 04991234
 The second 500 bytes
bytes 5009991234
 All except for the first 500 bytes
bytes 50012331234
 The last 500 bytes
bytes 73412331234
When an HTTP message includes the content of a single range for
example a response to a request for a single range or to a request
for a set of ranges that overlap without any holes this content is
transmitted with a ContentRange header and a ContentLength header
showing the number of bytes actually transferred For example
HTTP11 206 Partial content
Date Wed 15 Nov 1995 062524 GMT
LastModified Wed 15 Nov 1995 045808 GMT
ContentRange bytes 210104702147022
ContentLength 26012
ContentType imagegif
When an HTTP message includes the content of multiple ranges for
example a response to a request for multiple nonoverlapping
ranges these are transmitted as a multipart message The multipart
media type used for this purpose is multipartbyteranges as defined
in appendix 192 See appendix 1963 for a compatibility issue
A response to a request for a single range MUST NOT be sent using the
multipartbyteranges media type
A response to a request for
multiple ranges whose result is a single range MAY be sent as a
multipartbyteranges media type with one part A client that cannot
decode a multipartbyteranges message MUST NOT ask for multiple
byteranges in a single request
When a client requests multiple byteranges in one request the
server SHOULD return them in the order that they appeared in the
request
Fielding et al
Standards Track
Page 123
RFC 2616
HTTP11
June 1999
If the server ignores a byterangespec because it is syntactically
invalid the server SHOULD treat the request as if the invalid Range
header field did not exist Normally this means return a 200
response containing the full entity
If the server receives a request other than one including an If
Range requestheader field with an unsatisfiable Range request
header field that is all of whose byterangespec values have a
firstbytepos value greater than the current length of the selected
resource it SHOULD return a response code of 416 Requested range
not satisfiable section 10417
Note clients cannot depend on servers to send a 416 Requested
range not satisfiable response instead of a 200 OK response for
an unsatisfiable Range requestheader since not all servers
implement this requestheader
1417 ContentType
The ContentType entityheader field indicates the media type of the
entitybody sent to the recipient or in the case of the HEAD method
the media type that would have been sent had the request been a GET
ContentType
 ContentType  mediatype
Media types are defined in section 37 An example of the field is
ContentType texthtml charsetISO88594
Further discussion of methods for identifying the media type of an
entity is provided in section 721
1418 Date
The Date generalheader field represents the date and time at which
the message was originated having the same semantics as origdate in
RFC 822 The field value is an HTTPdate as described in section
331 it MUST be sent in RFC 1123 8date format
Date
 Date  HTTPdate
An example is
Date Tue 15 Nov 1994 081231 GMT
Origin servers MUST include a Date header field in all responses
except in these cases
Fielding et al
Standards Track
Page 124
RFC 2616
HTTP11
June 1999
1 If the response status code is 100 Continue or 101 Switching
Protocols the response MAY include a Date header field at
the servers option
2 If the response status code conveys a server error eg 500
Internal Server Error or 503 Service Unavailable and it is
inconvenient or impossible to generate a valid Date
3 If the server does not have a clock that can provide a
reasonable approximation of the current time its responses
MUST NOT include a Date header field In this case the rules
in section 14181 MUST be followed
A received message that does not have a Date header field MUST be
assigned one by the recipient if the message will be cached by that
recipient or gatewayed via a protocol which requires a Date An HTTP
implementation without a clock MUST NOT cache responses without
revalidating them on every use An HTTP cache especially a shared
cache SHOULD use a mechanism such as NTP 28 to synchronize its
clock with a reliable external standard
Clients SHOULD only send a Date header field in messages that include
an entitybody as in the case of the PUT and POST requests and even
then it is optional A client without a clock MUST NOT send a Date
header field in a request
The HTTPdate sent in a Date header SHOULD NOT represent a date and
time subsequent to the generation of the message It SHOULD represent
the best available approximation of the date and time of message
generation unless the implementation has no means of generating a
reasonably accurate date and time In theory the date ought to
represent the moment just before the entity is generated In
practice the date can be generated at any time during the message
origination without affecting its semantic value
14181 Clockless Origin Server Operation
Some origin server implementations might not have a clock available
An origin server without a clock MUST NOT assign Expires or Last
Modified values to a response unless these values were associated
with the resource by a system or user with a reliable clock It MAY
assign an Expires value that is known at or before server
configuration time to be in the past this allows preexpiration
of responses without storing separate Expires values for each
resource
Fielding et al
Standards Track
Page 125
RFC 2616
HTTP11
June 1999
1419 ETag
The ETag responseheader field provides the current value of the
entity tag for the requested variant The headers used with entity
tags are described in sections 1424 1426 and 1444 The entity tag
MAY be used for comparison with other entities from the same resource
see section 1333
ETag  ETag  entitytag
Examples
ETag xyzzy
ETag Wxyzzy
ETag
1420 Expect
The Expect requestheader field is used to indicate that particular
server behaviors are required by the client
Expect

Expect  1expectation
expectation

100continue  expectationextension
expectationextension
token    token  quotedstring
expectparams
expectparams
 token    token  quotedstring
A server that does not understand or is unable to comply with any of
the expectation values in the Expect field of a request MUST respond
with appropriate error status The server MUST respond with a 417
Expectation Failed status if any of the expectations cannot be met
or if there are other problems with the request some other 4xx
status
This header field is defined with extensible syntax to allow for
future extensions If a server receives a request containing an
Expect field that includes an expectationextension that it does not
support it MUST respond with a 417 Expectation Failed status
Comparison of expectation values is caseinsensitive for unquoted
tokens including the 100continue token and is casesensitive for
quotedstring expectationextensions
Fielding et al
Standards Track
Page 126
RFC 2616
HTTP11
June 1999
The Expect mechanism is hopbyhop that is an HTTP11 proxy MUST
return a 417 Expectation Failed status if it receives a request
with an expectation that it cannot meet However the Expect
requestheader itself is endtoend it MUST be forwarded if the
request is forwarded
Many older HTTP10 and HTTP11 applications do not understand the
Expect header
See section 823 for the use of the 100 continue status
1421 Expires
The Expires entityheader field gives the datetime after which the
response is considered stale A stale cache entry may not normally be
returned by a cache either a proxy cache or a user agent cache
unless it is first validated with the origin server or with an
intermediate cache that has a fresh copy of the entity See section
132 for further discussion of the expiration model
The presence of an Expires field does not imply that the original
resource will change or cease to exist at before or after that
time
The format is an absolute date and time as defined by HTTPdate in
section 331 it MUST be in RFC 1123 date format
Expires  Expires  HTTPdate
An example of its use is
Expires Thu 01 Dec 1994 160000 GMT
Note if a response includes a CacheControl field with the max
age directive see section 1493 that directive overrides the
Expires field
HTTP11 clients and caches MUST treat other invalid date formats
especially including the value 0 as in the past ie already
expired
To mark a response as already expired an origin server sends an
Expires date that is equal to the Date header value See the rules
for expiration calculations in section 1324
Fielding et al
Standards Track
Page 127
RFC 2616
HTTP11
June 1999
To mark a response as never expires an origin server sends an
Expires date approximately one year from the time the response is
sent HTTP11 servers SHOULD NOT send Expires dates more than one
year in the future
The presence of an Expires header field with a date value of some
time in the future on a response that otherwise would by default be
noncacheable indicates that the response is cacheable unless
indicated otherwise by a CacheControl header field section 149
1422 From
The From requestheader field if given SHOULD contain an Internet
email address for the human user who controls the requesting user
agent The address SHOULD be machineusable as defined by mailbox
in RFC 822 9 as updated by RFC 1123 8
From
 From  mailbox
An example is
From webmasterw3org
This header field MAY be used for logging purposes and as a means for
identifying the source of invalid or unwanted requests It SHOULD NOT
be used as an insecure form of access protection The interpretation
of this field is that the request is being performed on behalf of the
person given who accepts responsibility for the method performed In
particular robot agents SHOULD include this header so that the
person responsible for running the robot can be contacted if problems
occur on the receiving end
The Internet email address in this field MAY be separate from the
Internet host which issued the request For example when a request
is passed through a proxy the original issuers address SHOULD be
used
The client SHOULD NOT send the From header field without the users
approval as it might conflict with the users privacy interests or
their sites security policy It is strongly recommended that the
user be able to disable enable and modify the value of this field
at any time prior to a request
1423 Host
The Host requestheader field specifies the Internet host and port
number of the resource being requested as obtained from the original
URI given by the user or referring resource generally an HTTP URL
Fielding et al
Standards Track
Page 128
RFC 2616
HTTP11
June 1999
as described in section 322 The Host field value MUST represent
the naming authority of the origin server or gateway given by the
original URL This allows the origin server or gateway to
differentiate between internallyambiguous URLs such as the root
URL of a server for multiple host names on a single IP address
Host  Host  host   port   Section 322
A host without any trailing port information implies the default
port for the service requested eg 80 for an HTTP URL For
example a request on the origin server for
httpwwww3orgpubWWW would properly include
GET pubWWW HTTP11
Host wwww3org
A client MUST include a Host header field in all HTTP11 request
messages  If the requested URI does not include an Internet host
name for the service being requested then the Host header field MUST
be given with an empty value An HTTP11 proxy MUST ensure that any
request message it forwards does contain an appropriate Host header
field that identifies the service being requested by the proxy All
Internetbased HTTP11 servers MUST respond with a 400 Bad Request
status code to any HTTP11 request message which lacks a Host header
field
See sections 52 and 19611 for other requirements relating to
Host
1424 IfMatch
The IfMatch requestheader field is used with a method to make it
conditional A client that has one or more entities previously
obtained from the resource can verify that one of those entities is
current by including a list of their associated entity tags in the
IfMatch header field Entity tags are defined in section 311 The
purpose of this feature is to allow efficient updates of cached
information with a minimum amount of transaction overhead It is also
used on updating requests to prevent inadvertent modification of
the wrong version of a resource As a special case the value
matches any current entity of the resource
IfMatch  IfMatch     1entitytag
If any of the entity tags match the entity tag of the entity that
would have been returned in the response to a similar GET request
without the IfMatch header on that resource or if  is given
Fielding et al
Standards Track
Page 129
RFC 2616
HTTP11
June 1999
and any current entity exists for that resource then the server MAY
perform the requested method as if the IfMatch header field did not
exist
A server MUST use the strong comparison function see section 1333
to compare the entity tags in IfMatch
If none of the entity tags match or if  is given and no current
entity exists the server MUST NOT perform the requested method and
MUST return a 412 Precondition Failed response This behavior is
most useful when the client wants to prevent an updating method such
as PUT from modifying a resource that has changed since the client
last retrieved it
If the request would without the IfMatch header field result in
anything other than a 2xx or 412 status then the IfMatch header
MUST be ignored
The meaning of IfMatch  is that the method SHOULD be performed
if the representation selected by the origin server or by a cache
possibly using the Vary mechanism see section 1444 exists and
MUST NOT be performed if the representation does not exist
A request intended to update a resource eg a PUT MAY include an
IfMatch header field to signal that the request method MUST NOT be
applied if the entity corresponding to the IfMatch value a single
entity tag is no longer a representation of that resource This
allows the user to indicate that they do not wish the request to be
successful if the resource has been changed without their knowledge
Examples
IfMatch xyzzy
IfMatch xyzzy r2d2xxxx c3piozzzz
IfMatch
The result of a request having both an IfMatch header field and
either an IfNoneMatch or an IfModifiedSince header fields is
undefined by this specification
1425 IfModifiedSince
The IfModifiedSince requestheader field is used with a method to
make it conditional if the requested variant has not been modified
since the time specified in this field an entity will not be
returned from the server instead a 304 not modified response will
be returned without any messagebody
IfModifiedSince  IfModifiedSince  HTTPdate
Fielding et al
Standards Track
Page 130
RFC 2616
HTTP11
June 1999
An example of the field is
IfModifiedSince Sat 29 Oct 1994 194331 GMT
A GET method with an IfModifiedSince header and no Range header
requests that the identified entity be transferred only if it has
been modified since the date given by the IfModifiedSince header
The algorithm for determining this includes the following cases
a If the request would normally result in anything other than a
200 OK status or if the passed IfModifiedSince date is
invalid the response is exactly the same as for a normal GET
A date which is later than the servers current time is
invalid
b If the variant has been modified since the IfModifiedSince
date the response is exactly the same as for a normal GET
c If the variant has not been modified since a valid If
ModifiedSince date the server SHOULD return a 304 Not
Modified response
The purpose of this feature is to allow efficient updates of cached
information with a minimum amount of transaction overhead
Note The Range requestheader field modifies the meaning of If
ModifiedSince see section 1435 for full details
Note IfModifiedSince times are interpreted by the server whose
clock might not be synchronized with the client
Note When handling an IfModifiedSince header field some
servers will use an exact date comparison function rather than a
lessthan function for deciding whether to send a 304 Not
Modified response To get best results when sending an If
ModifiedSince header field for cache validation clients are
advised to use the exact date string received in a previous Last
Modified header field whenever possible
Note If a client uses an arbitrary date in the IfModifiedSince
header instead of a date taken from the LastModified header for
the same request the client should be aware of the fact that this
date is interpreted in the servers understanding of time The
client should consider unsynchronized clocks and rounding problems
due to the different encodings of time between the client and
server This includes the possibility of race conditions if the
document has changed between the time it was first requested and
the IfModifiedSince date of a subsequent request and the
Fielding et al
Standards Track
Page 131
RFC 2616
HTTP11
June 1999
possibility of clockskewrelated problems if the IfModified
Since date is derived from the clients clock without correction
to the servers clock Corrections for different time bases
between client and server are at best approximate due to network
latency
The result of a request having both an IfModifiedSince header field
and either an IfMatch or an IfUnmodifiedSince header fields is
undefined by this specification
1426 IfNoneMatch
The IfNoneMatch requestheader field is used with a method to make
it conditional A client that has one or more entities previously
obtained from the resource can verify that none of those entities is
current by including a list of their associated entity tags in the
IfNoneMatch header field The purpose of this feature is to allow
efficient updates of cached information with a minimum amount of
transaction overhead It is also used to prevent a method eg PUT
from inadvertently modifying an existing resource when the client
believes that the resource does not exist
As a special case the value  matches any current entity of the
resource
IfNoneMatch  IfNoneMatch     1entitytag
If any of the entity tags match the entity tag of the entity that
would have been returned in the response to a similar GET request
without the IfNoneMatch header on that resource or if  is
given and any current entity exists for that resource then the
server MUST NOT perform the requested method unless required to do
so because the resources modification date fails to match that
supplied in an IfModifiedSince header field in the request
Instead if the request method was GET or HEAD the server SHOULD
respond with a 304 Not Modified response including the cache
related header fields particularly ETag of one of the entities that
matched For all other request methods the server MUST respond with
a status of 412 Precondition Failed
See section 1333 for rules on how to determine if two entities tags
match The weak comparison function can only be used with GET or HEAD
requests
Fielding et al
Standards Track
Page 132
RFC 2616
HTTP11
June 1999
If none of the entity tags match then the server MAY perform the
requested method as if the IfNoneMatch header field did not exist
but MUST also ignore any IfModifiedSince header fields in the
request That is if no entity tags match then the server MUST NOT
return a 304 Not Modified response
If the request would without the IfNoneMatch header field result
in anything other than a 2xx or 304 status then the IfNoneMatch
header MUST be ignored See section 1334 for a discussion of
server behavior when both IfModifiedSince and IfNoneMatch appear
in the same request
The meaning of IfNoneMatch  is that the method MUST NOT be
performed if the representation selected by the origin server or by
a cache possibly using the Vary mechanism see section 1444
exists and SHOULD be performed if the representation does not exist
This feature is intended to be useful in preventing races between PUT
operations
Examples
IfNoneMatch xyzzy
IfNoneMatch Wxyzzy
IfNoneMatch xyzzy r2d2xxxx c3piozzzz
IfNoneMatch Wxyzzy Wr2d2xxxx Wc3piozzzz
IfNoneMatch
The result of a request having both an IfNoneMatch header field and
either an IfMatch or an IfUnmodifiedSince header fields is
undefined by this specification
1427 IfRange
If a client has a partial copy of an entity in its cache and wishes
to have an uptodate copy of the entire entity in its cache it
could use the Range requestheader with a conditional GET using
either or both of IfUnmodifiedSince and IfMatch However if the
condition fails because the entity has been modified the client
would then have to make a second request to obtain the entire current
entitybody
The IfRange header allows a client to shortcircuit the second
request Informally its meaning is if the entity is unchanged send
me the parts that I am missing otherwise send me the entire new
entity
IfRange  IfRange   entitytag  HTTPdate
Fielding et al
Standards Track
Page 133
RFC 2616
HTTP11
June 1999
If the client has no entity tag for an entity but does have a Last
Modified date it MAY use that date in an IfRange header The
server can distinguish between a valid HTTPdate and any form of
entitytag by examining no more than two characters The IfRange
header SHOULD only be used together with a Range header and MUST be
ignored if the request does not include a Range header or if the
server does not support the subrange operation
If the entity tag given in the IfRange header matches the current
entity tag for the entity then the server SHOULD provide the
specified subrange of the entity using a 206 Partial content
response If the entity tag does not match then the server SHOULD
return the entire entity using a 200 OK response
1428 IfUnmodifiedSince
The IfUnmodifiedSince requestheader field is used with a method to
make it conditional If the requested resource has not been modified
since the time specified in this field the server SHOULD perform the
requested operation as if the IfUnmodifiedSince header were not
present
If the requested variant has been modified since the specified time
the server MUST NOT perform the requested operation and MUST return
a 412 Precondition Failed
IfUnmodifiedSince  IfUnmodifiedSince  HTTPdate
An example of the field is
IfUnmodifiedSince Sat 29 Oct 1994 194331 GMT
If the request normally ie without the IfUnmodifiedSince
header would result in anything other than a 2xx or 412 status the
IfUnmodifiedSince header SHOULD be ignored
If the specified date is invalid the header is ignored
The result of a request having both an IfUnmodifiedSince header
field and either an IfNoneMatch or an IfModifiedSince header
fields is undefined by this specification
1429 LastModified
The LastModified entityheader field indicates the date and time at
which the origin server believes the variant was last modified
LastModified
 LastModified  HTTPdate
Fielding et al
Standards Track
Page 134
RFC 2616
HTTP11
June 1999
An example of its use is
LastModified Tue 15 Nov 1994 124526 GMT
The exact meaning of this header field depends on the implementation
of the origin server and the nature of the original resource For
files it may be just the file system lastmodified time For
entities with dynamically included parts it may be the most recent
of the set of lastmodify times for its component parts For database
gateways it may be the lastupdate time stamp of the record For
virtual objects it may be the last time the internal state changed
An origin server MUST NOT send a LastModified date which is later
than the servers time of message origination In such cases where
the resources last modification would indicate some time in the
future the server MUST replace that date with the message
origination date
An origin server SHOULD obtain the LastModified value of the entity
as close as possible to the time that it generates the Date value of
its response This allows a recipient to make an accurate assessment
of the entitys modification time especially if the entity changes
near the time that the response is generated
HTTP11 servers SHOULD send LastModified whenever feasible
1430 Location
The Location responseheader field is used to redirect the recipient
to a location other than the RequestURI for completion of the
request or identification of a new resource For 201 Created
responses the Location is that of the new resource which was created
by the request For 3xx responses the location SHOULD indicate the
servers preferred URI for automatic redirection to the resource The
field value consists of a single absolute URI
Location
 Location  absoluteURI
An example is
Location httpwwww3orgpubWWWPeoplehtml
Note The ContentLocation header field section 1414 differs
from Location in that the ContentLocation identifies the original
location of the entity enclosed in the request It is therefore
possible for a response to contain header fields for both Location
and ContentLocation Also see section 1310 for cache
requirements of some methods
Fielding et al
Standards Track
Page 135
RFC 2616
HTTP11
June 1999
1431 MaxForwards
The MaxForwards requestheader field provides a mechanism with the
TRACE section 98 and OPTIONS section 92 methods to limit the
number of proxies or gateways that can forward the request to the
next inbound server This can be useful when the client is attempting
to trace a request chain which appears to be failing or looping in
midchain
MaxForwards
 MaxForwards  1DIGIT
The MaxForwards value is a decimal integer indicating the remaining
number of times this request message may be forwarded
Each proxy or gateway recipient of a TRACE or OPTIONS request
containing a MaxForwards header field MUST check and update its
value prior to forwarding the request If the received value is zero
0 the recipient MUST NOT forward the request instead it MUST
respond as the final recipient If the received MaxForwards value is
greater than zero then the forwarded message MUST contain an updated
MaxForwards field with a value decremented by one 1
The MaxForwards header field MAY be ignored for all other methods
defined by this specification and for any extension methods for which
it is not explicitly referred to as part of that method definition
1432 Pragma
The Pragma generalheader field is used to include implementation
specific directives that might apply to any recipient along the
requestresponse chain All pragma directives specify optional
behavior from the viewpoint of the protocol however some systems
MAY require that behavior be consistent with the directives
Pragma
 Pragma  1pragmadirective
pragmadirective
 nocache  extensionpragma
extensionpragma
 token    token  quotedstring
When the nocache directive is present in a request message an
application SHOULD forward the request toward the origin server even
if it has a cached copy of what is being requested This pragma
directive has the same semantics as the nocache cachedirective see
section 149 and is defined here for backward compatibility with
HTTP10 Clients SHOULD include both header fields when a nocache
request is sent to a server not known to be HTTP11 compliant
Fielding et al
Standards Track
Page 136
RFC 2616
HTTP11
June 1999
Pragma directives MUST be passed through by a proxy or gateway
application regardless of their significance to that application
since the directives might be applicable to all recipients along the
requestresponse chain It is not possible to specify a pragma for a
specific recipient however any pragma directive not relevant to a
recipient SHOULD be ignored by that recipient
HTTP11 caches SHOULD treat Pragma nocache as if the client had
sent CacheControl nocache No new Pragma directives will be
defined in HTTP
Note because the meaning of Pragma nocache as a response
header field is not actually specified it does not provide a
reliable replacement for CacheControl nocache in a response
1433 ProxyAuthenticate
The ProxyAuthenticate responseheader field MUST be included as part
of a 407 Proxy Authentication Required response The field value
consists of a challenge that indicates the authentication scheme and
parameters applicable to the proxy for this RequestURI
ProxyAuthenticate
 ProxyAuthenticate  1challenge
The HTTP access authentication process is described in HTTP
Authentication Basic and Digest Access Authentication 43 Unlike
WWWAuthenticate the ProxyAuthenticate header field applies only to
the current connection and SHOULD NOT be passed on to downstream
clients However an intermediate proxy might need to obtain its own
credentials by requesting them from the downstream client which in
some circumstances will appear as if the proxy is forwarding the
ProxyAuthenticate header field
1434 ProxyAuthorization
The ProxyAuthorization requestheader field allows the client to
identify itself or its user to a proxy which requires
authentication The ProxyAuthorization field value consists of
credentials containing the authentication information of the user
agent for the proxy andor realm of the resource being requested
ProxyAuthorization
 ProxyAuthorization  credentials
The HTTP access authentication process is described in HTTP
Authentication Basic and Digest Access Authentication 43  Unlike
Authorization the ProxyAuthorization header field applies only to
the next outbound proxy that demanded authentication using the Proxy
Authenticate field When multiple proxies are used in a chain the
Fielding et al
Standards Track
Page 137
RFC 2616
HTTP11
June 1999
ProxyAuthorization header field is consumed by the first outbound
proxy that was expecting to receive credentials A proxy MAY relay
the credentials from the client request to the next proxy if that is
the mechanism by which the proxies cooperatively authenticate a given
request
1435 Range
14351 Byte Ranges
Since all HTTP entities are represented in HTTP messages as sequences
of bytes the concept of a byte range is meaningful for any HTTP
entity However not all clients and servers need to support byte
range operations
Byte range specifications in HTTP apply to the sequence of bytes in
the entitybody not necessarily the same as the messagebody
A byte range operation MAY specify a single range of bytes or a set
of ranges within a single entity
rangesspecifier  byterangesspecifier
byterangesspecifier  bytesunit  byterangeset
byterangeset
 1 byterangespec  suffixbyterangespec
byterangespec  firstbytepos  lastbytepos
firstbytepos
 1DIGIT
lastbytepos
 1DIGIT
The firstbytepos value in a byterangespec gives the byteoffset
of the first byte in a range The lastbytepos value gives the
byteoffset of the last byte in the range that is the byte
positions specified are inclusive Byte offsets start at zero
If the lastbytepos value is present it MUST be greater than or
equal to the firstbytepos in that byterangespec or the byte
rangespec is syntactically invalid The recipient of a byterange
set that includes one or more syntactically invalid byterangespec
values MUST ignore the header field that includes that byterange
set
If the lastbytepos value is absent or if the value is greater than
or equal to the current length of the entitybody lastbytepos is
taken to be equal to one less than the current length of the entity
body in bytes
By its choice of lastbytepos a client can limit the number of
bytes retrieved without knowing the size of the entity
Fielding et al
Standards Track
Page 138
RFC 2616
HTTP11
June 1999
suffixbyterangespec   suffixlength
suffixlength  1DIGIT
A suffixbyterangespec is used to specify the suffix of the
entitybody of a length given by the suffixlength value That is
this form specifies the last N bytes of an entitybody If the
entity is shorter than the specified suffixlength the entire
entitybody is used
If a syntactically valid byterangeset includes at least one byte
rangespec whose firstbytepos is less than the current length of
the entitybody or at least one suffixbyterangespec with a non
zero suffixlength then the byterangeset is satisfiable
Otherwise the byterangeset is unsatisfiable If the byterangeset
is unsatisfiable the server SHOULD return a response with a status
of 416 Requested range not satisfiable Otherwise the server
SHOULD return a response with a status of 206 Partial Content
containing the satisfiable ranges of the entitybody
Examples of byterangesspecifier values assuming an entitybody of
length 10000
 The first 500 bytes byte offsets 0499 inclusive
bytes0
499
 The second 500 bytes byte offsets 500999 inclusive
bytes500999
 The final 500 bytes byte offsets 95009999 inclusive
bytes500
 Or bytes9500
 The first and last bytes only bytes 0 and 9999
bytes001
 Several legal but not canonical specifications of the second 500
bytes byte offsets 500999 inclusive
bytes500600601999
bytes500700601999
14352 Range Retrieval Requests
HTTP retrieval requests using conditional or unconditional GET
methods MAY request one or more subranges of the entity instead of
the entire entity using the Range request header which applies to
the entity returned as the result of the request
Range  Range  rangesspecifier
Fielding et al
Standards Track
Page 139
RFC 2616
HTTP11
June 1999
A server MAY ignore the Range header However HTTP11 origin
servers and intermediate caches ought to support byte ranges when
possible since Range supports efficient recovery from partially
failed transfers and supports efficient partial retrieval of large
entities
If the server supports the Range header and the specified range or
ranges are appropriate for the entity
 The presence of a Range header in an unconditional GET modifies
what is returned if the GET is otherwise successful In other
words the response carries a status code of 206 Partial
Content instead of 200 OK
 The presence of a Range header in a conditional GET a request
using one or both of IfModifiedSince and IfNoneMatch or
one or both of IfUnmodifiedSince and IfMatch modifies what
is returned if the GET is otherwise successful and the
condition is true It does not affect the 304 Not Modified
response returned if the conditional is false
In some cases it might be more appropriate to use the IfRange
header see section 1427 in addition to the Range header
If a proxy that supports ranges receives a Range request forwards
the request to an inbound server and receives an entire entity in
reply it SHOULD only return the requested range to its client It
SHOULD store the entire received response in its cache if that is
consistent with its cache allocation policies
1436 Referer
The Referersic requestheader field allows the client to specify
for the servers benefit the address URI of the resource from
which the RequestURI was obtained the referrer although the
header field is misspelled The Referer requestheader allows a
server to generate lists of backlinks to resources for interest
logging optimized caching etc It also allows obsolete or mistyped
links to be traced for maintenance The Referer field MUST NOT be
sent if the RequestURI was obtained from a source that does not have
its own URI such as input from the user keyboard
Referer
 Referer   absoluteURI  relativeURI
Example
Referer httpwwww3orghypertextDataSourcesOverviewhtml
Fielding et al
Standards Track
Page 140
RFC 2616
HTTP11
June 1999
If the field value is a relative URI it SHOULD be interpreted
relative to the RequestURI The URI MUST NOT include a fragment See
section 1513 for security considerations
1437 RetryAfter
The RetryAfter responseheader field can be used with a 503 Service
Unavailable response to indicate how long the service is expected to
be unavailable to the requesting client This field MAY also be used
with any 3xx Redirection response to indicate the minimum time the
useragent is asked wait before issuing the redirected request The
value of this field can be either an HTTPdate or an integer number
of seconds in decimal after the time of the response
RetryAfter
 RetryAfter   HTTPdate  deltaseconds
Two examples of its use are
RetryAfter Fri 31 Dec 1999 235959 GMT
RetryAfter 120
In the latter example the delay is 2 minutes
1438 Server
The Server responseheader field contains information about the
software used by the origin server to handle the request The field
can contain multiple product tokens section 38 and comments
identifying the server and any significant subproducts The product
tokens are listed in order of their significance for identifying the
application
Server
 Server  1 product  comment
Example
Server CERN30 libwww217
If the response is being forwarded through a proxy the proxy
application MUST NOT modify the Server responseheader Instead it
SHOULD include a Via field as described in section 1445
Note Revealing the specific software version of the server might
allow the server machine to become more vulnerable to attacks
against software that is known to contain security holes Server
implementors are encouraged to make this field a configurable
option
Fielding et al
Standards Track
Page 141
RFC 2616
HTTP11
June 1999
1439 TE
The TE requestheader field indicates what extension transfercodings
it is willing to accept in the response and whether or not it is
willing to accept trailer fields in a chunked transfercoding Its
value may consist of the keyword trailers andor a commaseparated
list of extension transfercoding names with optional accept
parameters as described in section 36
TE
 TE   tcodings
tcodings  trailers   transferextension  acceptparams
The presence of the keyword trailers indicates that the client is
willing to accept trailer fields in a chunked transfercoding as
defined in section 361 This keyword is reserved for use with
transfercoding values even though it does not itself represent a
transfercoding
Examples of its use are
TE deflate
TE
TE trailers deflateq05
The TE header field only applies to the immediate connection
Therefore the keyword MUST be supplied within a Connection header
field section 1410 whenever TE is present in an HTTP11 message
A server tests whether a transfercoding is acceptable according to
a TE field using these rules
1 The chunked transfercoding is always acceptable If the
keyword trailers is listed the client indicates that it is
willing to accept trailer fields in the chunked response on
behalf of itself and any downstream clients The implication is
that if given the client is stating that either all
downstream clients are willing to accept trailer fields in the
forwarded response or that it will attempt to buffer the
response on behalf of downstream recipients
Note HTTP11 does not define any means to limit the size of a
chunked response such that a client can be assured of buffering
the entire response
2 If the transfercoding being tested is one of the transfer
codings listed in the TE field then it is acceptable unless it
is accompanied by a qvalue of 0 As defined in section 39 a
qvalue of 0 means not acceptable
Fielding et al
Standards Track
Page 142
RFC 2616
HTTP11
June 1999
3 If multiple transfercodings are acceptable then the
acceptable transfercoding with the highest nonzero qvalue is
preferred
The chunked transfercoding always has a qvalue
of 1
If the TE fieldvalue is empty or if no TE field is present the only
transfercoding
is chunked A message with no transfercoding is
always acceptable
1440 Trailer
The Trailer general field value indicates that the given set of
header fields is present in the trailer of a message encoded with
chunked transfercoding
Trailer
 Trailer  1fieldname
An HTTP11 message SHOULD include a Trailer header field in a
message using chunked transfercoding with a nonempty trailer Doing
so allows the recipient to know which header fields to expect in the
trailer
If no Trailer header field is present the trailer SHOULD NOT include
any header fields See section 361 for restrictions on the use of
trailer fields in a chunked transfercoding
Message header fields listed in the Trailer header field MUST NOT
include the following header fields
 TransferEncoding
 ContentLength
 Trailer
1441 TransferEncoding
The TransferEncoding generalheader field indicates what if any
type of transformation has been applied to the message body in order
to safely transfer it between the sender and the recipient This
differs from the contentcoding in that the transfercoding is a
property of the message not of the entity
TransferEncoding
 TransferEncoding  1transfercoding
Transfercodings are defined in section 36 An example is
TransferEncoding chunked
Fielding et al
Standards Track
Page 143
RFC 2616
HTTP11
June 1999
If multiple encodings have been applied to an entity the transfer
codings MUST be listed in the order in which they were applied
Additional information about the encoding parameters MAY be provided
by other entityheader fields not defined by this specification
Many older HTTP10 applications do not understand the Transfer
Encoding header
1442 Upgrade
The Upgrade generalheader allows the client to specify what
additional communication protocols it supports and would like to use
if the server finds it appropriate to switch protocols The server
MUST use the Upgrade header field within a 101 Switching Protocols
response to indicate which protocols are being switched
Upgrade
 Upgrade  1product
For example
Upgrade HTTP20 SHTTP13 IRC69 RTAx11
The Upgrade header field is intended to provide a simple mechanism
for transition from HTTP11 to some other incompatible protocol It
does so by allowing the client to advertise its desire to use another
protocol such as a later version of HTTP with a higher major version
number even though the current request has been made using HTTP11
This eases the difficult transition between incompatible protocols by
allowing the client to initiate a request in the more commonly
supported protocol while indicating to the server that it would like
to use a better protocol if available where better is determined
by the server possibly according to the nature of the method andor
resource being requested
The Upgrade header field only applies to switching applicationlayer
protocols upon the existing transportlayer connection Upgrade
cannot be used to insist on a protocol change its acceptance and use
by the server is optional The capabilities and nature of the
applicationlayer communication after the protocol change is entirely
dependent upon the new protocol chosen although the first action
after changing the protocol MUST be a response to the initial HTTP
request containing the Upgrade header field
The Upgrade header field only applies to the immediate connection
Therefore the upgrade keyword MUST be supplied within a Connection
header field section 1410 whenever Upgrade is present in an
HTTP11 message
Fielding et al
Standards Track
Page 144
RFC 2616
HTTP11
June 1999
The Upgrade header field cannot be used to indicate a switch to a
protocol on a different connection For that purpose it is more
appropriate to use a 301 302 303 or 305 redirection response
This specification only defines the protocol name HTTP for use by
the family of Hypertext Transfer Protocols as defined by the HTTP
version rules of section 31 and future updates to this
specification Any token can be used as a protocol name however it
will only be useful if both the client and server associate the name
with the same protocol
1443 UserAgent
The UserAgent requestheader field contains information about the
user agent originating the request This is for statistical purposes
the tracing of protocol violations and automated recognition of user
agents for the sake of tailoring responses to avoid particular user
agent limitations User agents SHOULD include this field with
requests The field can contain multiple product tokens section 38
and comments identifying the agent and any subproducts which form a
significant part of the user agent By convention the product tokens
are listed in order of their significance for identifying the
application
UserAgent
 UserAgent  1 product  comment
Example
UserAgent CERNLineMode215 libwww217b3
1444 Vary
The Vary field value indicates the set of requestheader fields that
fully determines while the response is fresh whether a cache is
permitted to use the response to reply to a subsequent request
without revalidation For uncacheable or stale responses the Vary
field value advises the user agent about the criteria that were used
to select the representation A Vary field value of  implies that
a cache cannot determine from the request headers of a subsequent
request whether this response is the appropriate representation See
section 136 for use of the Vary header field by caches
Vary
 Vary     1fieldname
An HTTP11 server SHOULD include a Vary header field with any
cacheable response that is subject to serverdriven negotiation
Doing so allows a cache to properly interpret future requests on that
resource and informs the user agent about the presence of negotiation
Fielding et al
Standards Track
Page 145
RFC 2616
HTTP11
June 1999
on that resource A server MAY include a Vary header field with a
noncacheable response that is subject to serverdriven negotiation
since this might provide the user agent with useful information about
the dimensions over which the response varies at the time of the
response
A Vary field value consisting of a list of fieldnames signals that
the representation selected for the response is based on a selection
algorithm which considers ONLY the listed requestheader field values
in selecting the most appropriate representation A cache MAY assume
that the same selection will be made for future requests with the
same values for the listed field names for the duration of time for
which the response is fresh
The fieldnames given are not limited to the set of standard
requestheader fields defined by this specification Field names are
caseinsensitive
A Vary field value of  signals that unspecified parameters not
limited to the requestheaders eg the network address of the
client play a role in the selection of the response representation
The  value MUST NOT be generated by a proxy server it may only be
generated by an origin server
1445
Via
The Via generalheader field MUST be used by gateways and proxies to
indicate the intermediate protocols and recipients between the user
agent and the server on requests and between the origin server and
the client on responses It is analogous to the Received field of
RFC 822 9 and is intended to be used for tracking message forwards
avoiding request loops and identifying the protocol capabilities of
all senders along the requestresponse chain
Via
Via  1 receivedprotocol receivedby  comment
receivedprotocol   protocolname   protocolversion
protocolname
 token
protocolversion
 token
receivedby
  host   port    pseudonym
pseudonym
 token
The receivedprotocol indicates the protocol version of the message
received by the server or client along each segment of the
requestresponse chain The receivedprotocol version is appended to
the Via field value when the message is forwarded so that information
about the protocol capabilities of upstream applications remains
visible to all recipients
Fielding et al
Standards Track
Page 146
RFC 2616
HTTP11
June 1999
The protocolname is optional if and only if it would be HTTP The
receivedby field is normally the host and optional port number of a
recipient server or client that subsequently forwarded the message
However if the real host is considered to be sensitive information
it MAY be replaced by a pseudonym If the port is not given it MAY
be assumed to be the default port of the receivedprotocol
Multiple Via field values represents each proxy or gateway that has
forwarded the message Each recipient MUST append its information
such that the end result is ordered according to the sequence of
forwarding applications
Comments MAY be used in the Via header field to identify the software
of the recipient proxy or gateway analogous to the UserAgent and
Server header fields However all comments in the Via field are
optional and MAY be removed by any recipient prior to forwarding the
message
For example a request message could be sent from an HTTP10 user
agent to an internal proxy codenamed fred which uses HTTP11 to
forward the request to a public proxy at nowherecom which completes
the request by forwarding it to the origin server at wwwicsuciedu
The request received by wwwicsuciedu would then have the following
Via header field
Via 10 fred 11 nowherecom Apache11
Proxies and gateways used as a portal through a network firewall
SHOULD NOT by default forward the names and ports of hosts within
the firewall region This information SHOULD only be propagated if
explicitly enabled If not enabled the receivedby host of any host
behind the firewall SHOULD be replaced by an appropriate pseudonym
for that host
For organizations that have strong privacy requirements for hiding
internal structures a proxy MAY combine an ordered subsequence of
Via header field entries with identical receivedprotocol values into
a single such entry For example
Via 10 ricky 11 ethel 11 fred 10 lucy
could be collapsed to
Via 10 ricky 11 mertz 10 lucy
Fielding et al
Standards Track
Page 147
RFC 2616
HTTP11
June 1999
Applications SHOULD NOT combine multiple entries unless they are all
under the same organizational control and the hosts have already been
replaced by pseudonyms Applications MUST NOT combine entries which
have different receivedprotocol values
1446 Warning
The Warning generalheader field is used to carry additional
information about the status or transformation of a message which
might not be reflected in the message This information is typically
used to warn about a possible lack of semantic transparency from
caching operations or transformations applied to the entity body of
the message
Warning headers are sent with responses using
Warning
 Warning  1warningvalue
warningvalue  warncode SP warnagent SP warntext
SP warndate
warncode
 3DIGIT
warnagent   host   port    pseudonym
 the name or pseudonym of the server adding
 the Warning header for use in debugging
warntext
 quotedstring
warndate
  HTTPdate
A response MAY carry more than one Warning header
The warntext SHOULD be in a natural language and character set that
is most likely to be intelligible to the human user receiving the
response This decision MAY be based on any available knowledge such
as the location of the cache or user the AcceptLanguage field in a
request the ContentLanguage field in a response etc The default
language is English and the default character set is ISO88591
If a character set other than ISO88591 is used it MUST be encoded
in the warntext using the method described in RFC 2047 14
Warning headers can in general be applied to any message however
some specific warncodes are specific to caches and can only be
applied to response messages New Warning headers SHOULD be added
after any existing Warning headers A cache MUST NOT delete any
Warning header that it received with a message However if a cache
successfully validates a cache entry it SHOULD remove any Warning
headers previously attached to that entry except as specified for
Fielding et al
Standards Track
Page 148
RFC 2616
HTTP11
June 1999
specific Warning codes It MUST then add any Warning headers received
in the validating response In other words Warning headers are those
that would be attached to the most recent relevant response
When multiple Warning headers are attached to a response the user
agent ought to inform the user of as many of them as possible in the
order that they appear in the response If it is not possible to
inform the user of all of the warnings the user agent SHOULD follow
these heuristics
 Warnings that appear early in the response take priority over
those appearing later in the response
 Warnings in the users preferred character set take priority
over warnings in other character sets but with identical warn
codes and warnagents
Systems that generate multiple Warning headers SHOULD order them with
this user agent behavior in mind
Requirements for the behavior of caches with respect to Warnings are
stated in section 1312
This is a list of the currentlydefined warncodes each with a
recommended warntext in English and a description of its meaning
110 Response is stale
MUST be included whenever the returned response is stale
111 Revalidation failed
MUST be included if a cache returns a stale response because an
attempt to revalidate the response failed due to an inability to
reach the server
112 Disconnected operation
SHOULD be included if the cache is intentionally disconnected from
the rest of the network for a period of time
113 Heuristic expiration
MUST be included if the cache heuristically chose a freshness
lifetime greater than 24 hours and the responses age is greater
than 24 hours
199 Miscellaneous warning
The warning text MAY include arbitrary information to be presented
to a human user or logged A system receiving this warning MUST
NOT take any automated action besides presenting the warning to
the user
Fielding et al
Standards Track
Page 149
RFC 2616
HTTP11
June 1999
214 Transformation applied
MUST be added by an intermediate cache or proxy if it applies any
transformation changing the contentcoding as specified in the
ContentEncoding header or mediatype as specified in the
ContentType header of the response or the entitybody of the
response unless this Warning code already appears in the response
299 Miscellaneous persistent warning
The warning text MAY include arbitrary information to be presented
to a human user or logged A system receiving this warning MUST
NOT take any automated action
If an implementation sends a message with one or more Warning headers
whose version is HTTP10 or lower then the sender MUST include in
each warningvalue a warndate that matches the date in the response
If an implementation receives a message with a warningvalue that
includes a warndate and that warndate is different from the Date
value in the response then that warningvalue MUST be deleted from
the message before storing forwarding or using it This prevents
bad consequences of naive caching of Warning header fields If all
of the warningvalues are deleted for this reason the Warning header
MUST be deleted as well
1447 WWWAuthenticate
The WWWAuthenticate responseheader field MUST be included in 401
Unauthorized response messages The field value consists of at
least one challenge that indicates the authentication schemes and
parameters applicable to the RequestURI
WWWAuthenticate
 WWWAuthenticate  1challenge
The HTTP access authentication process is described in HTTP
Authentication Basic and Digest Access Authentication 43 User
agents are advised to take special care in parsing the WWW
Authenticate field value as it might contain more than one challenge
or if more than one WWWAuthenticate header field is provided the
contents of a challenge itself can contain a commaseparated list of
authentication parameters
15 Security Considerations
This section is meant to inform application developers information
providers and users of the security limitations in HTTP11 as
described by this document The discussion does not include
definitive solutions to the problems revealed though it does make
some suggestions for reducing security risks
Fielding et al
Standards Track
Page 150
RFC 2616
HTTP11
June 1999
151 Personal Information
HTTP clients are often privy to large amounts of personal information
eg the users name location mail address passwords encryption
keys etc and SHOULD be very careful to prevent unintentional
leakage of this information via the HTTP protocol to other sources
We very strongly recommend that a convenient interface be provided
for the user to control dissemination of such information and that
designers and implementors be particularly careful in this area
History shows that errors in this area often create serious security
andor privacy problems and generate highly adverse publicity for the
implementors company
1511 Abuse of Server Log Information
A server is in the position to save personal data about a users
requests which might identify their reading patterns or subjects of
interest This information is clearly confidential in nature and its
handling can be constrained by law in certain countries People using
the HTTP protocol to provide data are responsible for ensuring that
such material is not distributed without the permission of any
individuals that are identifiable by the published results
1512 Transfer of Sensitive Information
Like any generic data transfer protocol HTTP cannot regulate the
content of the data that is transferred nor is there any a priori
method of determining the sensitivity of any particular piece of
information within the context of any given request Therefore
applications SHOULD supply as much control over this information as
possible to the provider of that information Four header fields are
worth special mention in this context Server Via Referer and From
Revealing the specific software version of the server might allow the
server machine to become more vulnerable to attacks against software
that is known to contain security holes Implementors SHOULD make the
Server header field a configurable option
Proxies which serve as a portal through a network firewall SHOULD
take special precautions regarding the transfer of header information
that identifies the hosts behind the firewall In particular they
SHOULD remove or replace with sanitized versions any Via fields
generated behind the firewall
The Referer header allows reading patterns to be studied and reverse
links drawn Although it can be very useful its power can be abused
if user details are not separated from the information contained in
Fielding et al
Standards Track
Page 151
RFC 2616
HTTP11
June 1999
the Referer Even when the personal information has been removed the
Referer header might indicate a private documents URI whose
publication would be inappropriate
The information sent in the From field might conflict with the users
privacy interests or their sites security policy and hence it
SHOULD NOT be transmitted without the user being able to disable
enable and modify the contents of the field The user MUST be able
to set the contents of this field within a user preference or
application defaults configuration
We suggest though do not require that a convenient toggle interface
be provided for the user to enable or disable the sending of From and
Referer information
The UserAgent section 1443 or Server section 1438 header
fields can sometimes be used to determine that a specific client or
server have a particular security hole which might be exploited
Unfortunately this same information is often used for other valuable
purposes for which HTTP currently has no better mechanism
1513 Encoding Sensitive Information in URIs
Because the source of a link might be private information or might
reveal an otherwise private information source it is strongly
recommended that the user be able to select whether or not the
Referer field is sent For example a browser client could have a
toggle switch for browsing openlyanonymously which would
respectively enabledisable the sending of Referer and From
information
Clients SHOULD NOT include a Referer header field in a nonsecure
HTTP request if the referring page was transferred with a secure
protocol
Authors of services which use the HTTP protocol SHOULD NOT use GET
based forms for the submission of sensitive data because this will
cause this data to be encoded in the RequestURI Many existing
servers proxies and user agents will log the request URI in some
place where it might be visible to third parties Servers can use
POSTbased form submission instead
1514 Privacy Issues Connected to Accept Headers
Accept requestheaders can reveal information about the user to all
servers which are accessed The AcceptLanguage header in particular
can reveal information the user would consider to be of a private
nature because the understanding of particular languages is often
Fielding et al
Standards Track
Page 152
RFC 2616
HTTP11
June 1999
strongly correlated to the membership of a particular ethnic group
User agents which offer the option to configure the contents of an
AcceptLanguage header to be sent in every request are strongly
encouraged to let the configuration process include a message which
makes the user aware of the loss of privacy involved
An approach that limits the loss of privacy would be for a user agent
to omit the sending of AcceptLanguage headers by default and to ask
the user whether or not to start sending AcceptLanguage headers to a
server if it detects by looking for any Vary responseheader fields
generated by the server that such sending could improve the quality
of service
Elaborate usercustomized accept header fields sent in every request
in particular if these include quality values can be used by servers
as relatively reliable and longlived user identifiers Such user
identifiers would allow content providers to do clicktrail tracking
and would allow collaborating content providers to match crossserver
clicktrails or form submissions of individual users Note that for
many users not behind a proxy the network address of the host
running the user agent will also serve as a longlived user
identifier In environments where proxies are used to enhance
privacy user agents ought to be conservative in offering accept
header configuration options to end users As an extreme privacy
measure proxies could filter the accept headers in relayed requests
General purpose user agents which provide a high degree of header
configurability SHOULD warn users about the loss of privacy which can
be involved
152 Attacks Based On File and Path Names
Implementations of HTTP origin servers SHOULD be careful to restrict
the documents returned by HTTP requests to be only those that were
intended by the server administrators If an HTTP server translates
HTTP URIs directly into file system calls the server MUST take
special care not to serve files that were not intended to be
delivered to HTTP clients For example UNIX Microsoft Windows and
other operating systems use  as a path component to indicate a
directory level above the current one On such a system an HTTP
server MUST disallow any such construct in the RequestURI if it
would otherwise allow access to a resource outside those intended to
be accessible via the HTTP server Similarly files intended for
reference only internally to the server such as access control
files configuration files and script code MUST be protected from
inappropriate retrieval since they might contain sensitive
information Experience has shown that minor bugs in such HTTP server
implementations have turned into security risks
Fielding et al
Standards Track
Page 153
RFC 2616
HTTP11
June 1999
153 DNS Spoofing
Clients using HTTP rely heavily on the Domain Name Service and are
thus generally prone to security attacks based on the deliberate
misassociation of IP addresses and DNS names Clients need to be
cautious in assuming the continuing validity of an IP numberDNS name
association
In particular HTTP clients SHOULD rely on their name resolver for
confirmation of an IP numberDNS name association rather than
caching the result of previous host name lookups Many platforms
already can cache host name lookups locally when appropriate and
they SHOULD be configured to do so It is proper for these lookups to
be cached however only when the TTL Time To Live information
reported by the name server makes it likely that the cached
information will remain useful
If HTTP clients cache the results of host name lookups in order to
achieve a performance improvement they MUST observe the TTL
information reported by DNS
If HTTP clients do not observe this rule they could be spoofed when
a previouslyaccessed servers IP address changes As network
renumbering is expected to become increasingly common 24 the
possibility of this form of attack will grow Observing this
requirement thus reduces this potential security vulnerability
This requirement also improves the loadbalancing behavior of clients
for replicated servers using the same DNS name and reduces the
likelihood of a users experiencing failure in accessing sites which
use that strategy
154 Location Headers and Spoofing
If a single server supports multiple organizations that do not trust
one another then it MUST check the values of Location and Content
Location headers in responses that are generated under control of
said organizations to make sure that they do not attempt to
invalidate resources over which they have no authority
155 ContentDisposition Issues
RFC 1806 35 from which the often implemented ContentDisposition
see section 1951 header in HTTP is derived has a number of very
serious security considerations ContentDisposition is not part of
the HTTP standard but since it is widely implemented we are
documenting its use and risks for implementors See RFC 2183 49
which updates RFC 1806 for details
Fielding et al
Standards Track
Page 154
RFC 2616
HTTP11
June 1999
156 Authentication Credentials and Idle Clients
Existing HTTP clients and user agents typically retain authentication
information indefinitely HTTP11 does not provide a method for a
server to direct clients to discard these cached credentials This is
a significant defect that requires further extensions to HTTP
Circumstances under which credential caching can interfere with the
applications security model include but are not limited to
 Clients which have been idle for an extended period following
which the server might wish to cause the client to reprompt the
user for credentials
 Applications which include a session termination indication
such as a logout or commit button on a page after which
the server side of the application knows that there is no
further reason for the client to retain the credentials
This is currently under separate study There are a number of work
arounds to parts of this problem and we encourage the use of
password protection in screen savers idle timeouts and other
methods which mitigate the security problems inherent in this
problem In particular user agents which cache credentials are
encouraged to provide a readily accessible mechanism for discarding
cached credentials under user control
157 Proxies and Caching
By their very nature HTTP proxies are meninthemiddle and
represent an opportunity for maninthemiddle attacks Compromise of
the systems on which the proxies run can result in serious security
and privacy problems Proxies have access to securityrelated
information personal information about individual users and
organizations and proprietary information belonging to users and
content providers A compromised proxy or a proxy implemented or
configured without regard to security and privacy considerations
might be used in the commission of a wide range of potential attacks
Proxy operators should protect the systems on which proxies run as
they would protect any system that contains or transports sensitive
information In particular log information gathered at proxies often
contains highly sensitive personal information andor information
about organizations Log information should be carefully guarded and
appropriate guidelines for use developed and followed Section
1511
Fielding et al
Standards Track
Page 155
RFC 2616
HTTP11
June 1999
Caching proxies provide additional potential vulnerabilities since
the contents of the cache represent an attractive target for
malicious exploitation Because cache contents persist after an HTTP
request is complete an attack on the cache can reveal information
long after a user believes that the information has been removed from
the network Therefore cache contents should be protected as
sensitive information
Proxy implementors should consider the privacy and security
implications of their design and coding decisions and of the
configuration options they provide to proxy operators especially the
default configuration
Users of a proxy need to be aware that they are no trustworthier than
the people who run the proxy HTTP itself cannot solve this problem
The judicious use of cryptography when appropriate may suffice to
protect against a broad range of security and privacy attacks Such
cryptography is beyond the scope of the HTTP11 specification
1571 Denial of Service Attacks on Proxies
They exist They are hard to defend against Research continues
Beware
16 Acknowledgments
This specification makes heavy use of the augmented BNF and generic
constructs defined by David H Crocker for RFC 822 9 Similarly it
reuses many of the definitions provided by Nathaniel Borenstein and
Ned Freed for MIME 7 We hope that their inclusion in this
specification will help reduce past confusion over the relationship
between HTTP and Internet mail message formats
The HTTP protocol has evolved considerably over the years It has
benefited from a large and active developer communitythe many
people who have participated on the wwwtalk mailing listand it is
that community which has been most responsible for the success of
HTTP and of the WorldWide Web in general Marc Andreessen Robert
Cailliau Daniel W Connolly Bob Denny John Franks JeanFrancois
Groff Phillip M HallamBaker Hakon W Lie Ari Luotonen Rob
McCool Lou Montulli Dave Raggett Tony Sanders and Marc
VanHeyningen deserve special recognition for their efforts in
defining early aspects of the protocol
This document has benefited greatly from the comments of all those
participating in the HTTPWG In addition to those already mentioned
the following individuals have contributed to this specification
Fielding et al
Standards Track
Page 156
RFC 2616
HTTP11
June 1999
Gary Adams
Ross Patterson
Harald Tveit Alvestrand
Albert Lunde
Keith Ball
John C Mallery
Brian Behlendorf
JeanPhilippe MartinFlatin
Paul Burchard
Mitra
Maurizio Codogno
David Morris
Mike Cowlishaw
Gavin Nicol
Roman Czyborra
Bill Perry
Michael A Dolan
Jeffrey Perry
David J Fiander
Scott Powers
Alan Freier
Owen Rees
Marc Hedlund
Luigi Rizzo
Greg Herlihy
David Robinson
Koen Holtman
Marc Salomon
Alex Hopmann
Rich Salz
Bob Jernigan
Allan M Schiffman
Shel Kaphan
Jim Seidman
Rohit Khare
Chuck Shotton
John Klensin
Eric W Sink
Martijn Koster
Simon E Spero
Alexei Kosut
Richard N Taylor
David M Kristol
Robert S Thau
Daniel LaLiberte
Bill BearHeart Weinman
Ben Laurie
Francois Yergeau
Paul J Leach
Mary Ellen Zurko
Daniel DuBois
Josh Cohen
Much of the content and presentation of the caching design is due to
suggestions and comments from individuals including Shel Kaphan
Paul Leach Koen Holtman David Morris and Larry Masinter
Most of the specification of ranges is based on work originally done
by Ari Luotonen and John Franks with additional input from Steve
Zilles
Thanks to the cave men of Palo Alto You know who you are
Jim Gettys the current editor of this document wishes particularly
to thank Roy Fielding the previous editor of this document along
with John Klensin Jeff Mogul Paul Leach Dave Kristol Koen
Holtman John Franks Josh Cohen Alex Hopmann Scott Lawrence and
Larry Masinter for their help And thanks go particularly to Jeff
Mogul and Scott Lawrence for performing the MUSTMAYSHOULD audit
Fielding et al
Standards Track
Page 157
RFC 2616
HTTP11
June 1999
The Apache Group Anselm BairdSmith author of Jigsaw and Henrik
Frystyk implemented RFC 2068 early and we wish to thank them for the
discovery of many of the problems that this document attempts to
rectify
17 References
1 Alvestrand H Tags for the Identification of Languages RFC
1766 March 1995
2 Anklesaria F McCahill M Lindner P Johnson D Torrey
D and B Alberti The Internet Gopher Protocol a distributed
document search and retrieval protocol RFC 1436 March 1993
3 BernersLee T Universal Resource Identifiers in WWW RFC
1630 June 1994
4 BernersLee T Masinter L and M McCahill Uniform Resource
Locators URL RFC 1738 December 1994
5 BernersLee T and D Connolly Hypertext Markup Language
20 RFC 1866 November 1995
6 BernersLee T Fielding R and H Frystyk Hypertext Transfer
Protocol  HTTP10 RFC 1945 May 1996
7 Freed N and N Borenstein Multipurpose Internet Mail
Extensions MIME Part One Format of Internet Message Bodies
RFC 2045 November 1996
8 Braden R Requirements for Internet Hosts  Communication
Layers STD 3 RFC 1123 October 1989
9 Crocker D Standard for The Format of ARPA Internet Text
Messages STD 11 RFC 822 August 1982
10 Davis F Kahle B Morris H Salem J Shen T Wang R
Sui J and M Grinbaum WAIS Interface Protocol Prototype
Functional Specification v15 Thinking Machines
Corporation April 1990
11 Fielding R Relative Uniform Resource Locators RFC 1808
June 1995
12 Horton M and R Adams Standard for Interchange of USENET
Messages RFC 1036 December 1987
Fielding et al
Standards Track
Page 158
RFC 2616
HTTP11
June 1999
13 Kantor B and P Lapsley Network News Transfer Protocol RFC
977 February 1986
14 Moore K MIME Multipurpose Internet Mail Extensions Part
Three Message Header Extensions for NonASCII Text RFC 2047
November 1996
15 Nebel E and L Masinter Formbased File Upload in HTML RFC
1867 November 1995
16 Postel J Simple Mail Transfer Protocol STD 10 RFC 821
August 1982
17 Postel J Media Type Registration Procedure RFC 1590
November 1996
18 Postel J and J Reynolds File Transfer Protocol STD 9 RFC
959 October 1985
19 Reynolds J and J Postel Assigned Numbers STD 2 RFC 1700
October 1994
20 Sollins K and L Masinter Functional Requirements for
Uniform Resource Names RFC 1737 December 1994
21 USASCII Coded Character Set  7Bit American Standard Code for
Information Interchange Standard ANSI X341986 ANSI 1986
22 ISO8859 International Standard  Information Processing
8bit SingleByte Coded Graphic Character Sets
Part 1 Latin alphabet No 1 ISO885911987
Part 2 Latin alphabet No 2 ISO88592 1987
Part 3 Latin alphabet No 3 ISO88593 1988
Part 4 Latin alphabet No 4 ISO88594 1988
Part 5 LatinCyrillic alphabet ISO88595 1988
Part 6 LatinArabic alphabet ISO88596 1987
Part 7 LatinGreek alphabet ISO88597 1987
Part 8 LatinHebrew alphabet ISO88598 1988
Part 9 Latin alphabet No 5 ISO88599 1990
23 Meyers J and M Rose The ContentMD5 Header Field RFC
1864 October 1995
24 Carpenter B and Y Rekhter Renumbering Needs Work RFC
1900 February 1996
25 Deutsch P GZIP file format specification version 43 RFC
1952 May 1996
Fielding et al
Standards Track
Page 159
RFC 2616
HTTP11
June 1999
26 Venkata N Padmanabhan and Jeffrey C Mogul Improving HTTP
Latency Computer Networks and ISDN Systems v 28 pp 2535
Dec 1995 Slightly revised version of paper in Proc 2nd
International WWW Conference 94 Mosaic and the Web Oct 1994
which is available at
httpwwwncsauiuceduSDGIT94ProceedingsDDaymogulHTTPLat
encyhtml
27 Joe Touch John Heidemann and Katia Obraczka Analysis of HTTP
Performance URL httpwwwisiedutouchpubshttpperf96
ISI Research Report ISIRR98463 original report dated Aug
1996 USCInformation Sciences Institute August 1998
28 Mills D Network Time Protocol Version 3 Specification
Implementation and Analysis RFC 1305 March 1992
29 Deutsch P DEFLATE Compressed Data Format Specification
version 13 RFC 1951 May 1996
30 S Spero Analysis of HTTP Performance Problems
httpsunsiteuncedumdmareleasehttpprobhtml
31 Deutsch P and J Gailly ZLIB Compressed Data Format
Specification version 33 RFC 1950 May 1996
32 Franks J HallamBaker P Hostetler J Leach P
Luotonen A Sink E and L Stewart An Extension to HTTP
Digest Access Authentication RFC 2069 January 1997
33 Fielding R Gettys J Mogul J Frystyk H and T
BernersLee Hypertext Transfer Protocol  HTTP11 RFC
2068 January 1997
34 Bradner S Key words for use in RFCs to Indicate Requirement
Levels BCP 14 RFC 2119 March 1997
35 Troost R and Dorner S Communicating Presentation
Information in Internet Messages The ContentDisposition
Header RFC 1806 June 1995
36 Mogul J Fielding R Gettys J and H Frystyk Use and
Interpretation of HTTP Version Numbers RFC 2145 May 1997
jg639
37 Palme J Common Internet Message Headers RFC 2076 February
1997 jg640
Fielding et al
Standards Track
Page 160
RFC 2616
HTTP11
June 1999
38 Yergeau F UTF8 a transformation format of Unicode and
ISO10646 RFC 2279 January 1998 jg641
39 Nielsen HF Gettys J BairdSmith A Prudhommeaux E
Lie H and C Lilley Network Performance Effects of
HTTP11 CSS1 and PNG Proceedings of ACM SIGCOMM 97 Cannes
France September 1997jg642
40 Freed N and N Borenstein Multipurpose Internet Mail
Extensions MIME Part Two Media Types RFC 2046 November
1996 jg643
41 Alvestrand H IETF Policy on Character Sets and Languages
BCP 18 RFC 2277 January 1998 jg644
42 BernersLee T Fielding R and L Masinter Uniform Resource
Identifiers URI Generic Syntax and Semantics RFC 2396
August 1998 jg645
43 Franks J HallamBaker P Hostetler J Lawrence S
Leach P Luotonen A Sink E and L Stewart HTTP
Authentication Basic and Digest Access Authentication RFC
2617 June 1999 jg646
44 Luotonen A Tunneling TCP based protocols through Web proxy
servers Work in Progress jg647
45 Palme J and A Hopmann MIME Email Encapsulation of
Aggregate Documents such as HTML MHTML RFC 2110 March
1997
46 Bradner S The Internet Standards Process  Revision 3 BCP
9 RFC 2026 October 1996
47 Masinter L Hyper Text Coffee Pot Control Protocol
HTCPCP10 RFC 2324 1 April 1998
48 Freed N and N Borenstein Multipurpose Internet Mail
Extensions MIME Part Five Conformance Criteria and Examples
RFC 2049 November 1996
49 Troost R Dorner S and K Moore Communicating Presentation
Information in Internet Messages The ContentDisposition Header
Field RFC 2183 August 1997
Fielding et al
Standards Track
Page 161
RFC 2616
HTTP11
June 1999
18 Authors Addresses
Roy T Fielding
Information and Computer Science
University of California Irvine
Irvine CA 926973425 USA
Fax +1 949 8241715
EMail fieldingicsuciedu
James Gettys
World Wide Web Consortium
MIT Laboratory for Computer Science
545 Technology Square
Cambridge MA 02139 USA
Fax +1 617 258 8682
EMail jgw3org
Jeffrey C Mogul
Western Research Laboratory
Compaq Computer Corporation
250 University Avenue
Palo Alto California 94305 USA
EMail mogulwrldeccom
Henrik Frystyk Nielsen
World Wide Web Consortium
MIT Laboratory for Computer Science
545 Technology Square
Cambridge MA 02139 USA
Fax +1 617 258 8682
EMail frystykw3org
Larry Masinter
Xerox Corporation
3333 Coyote Hill Road
Palo Alto CA 94034 USA
EMail masinterparcxeroxcom
Fielding et al
Standards Track
Page 162
RFC 2616
HTTP11
June 1999
Paul J Leach
Microsoft Corporation
1 Microsoft Way
Redmond WA 98052 USA
EMail paullemicrosoftcom
Tim BernersLee
Director World Wide Web Consortium
MIT Laboratory for Computer Science
545 Technology Square
Cambridge MA 02139 USA
Fax +1 617 258 8682
EMail timblw3org
Fielding et al
Standards Track
Page 163
RFC 2616
HTTP11
June 1999
19 Appendices
191 Internet Media Type messagehttp and applicationhttp
In addition to defining the HTTP11 protocol this document serves
as the specification for the Internet media type messagehttp and
applicationhttp The messagehttp type can be used to enclose a
single HTTP request or response message provided that it obeys the
MIME restrictions for all message types regarding line length and
encodings The applicationhttp type can be used to enclose a
pipeline of one or more HTTP request or response messages not
intermixed The following is to be registered with IANA 17
Media Type name
message
Media subtype name
http
Required parameters
none
Optional parameters
version msgtype
version The HTTPVersion number of the enclosed message
eg 11 If not present the version can be
determined from the first line of the body
msgtype The message type  request or response If not
present the type can be determined from the first
line of the body
Encoding considerations only 7bit 8bit or binary are
permitted
Security considerations none
Media Type name
application
Media subtype name
http
Required parameters
none
Optional parameters
version msgtype
version The HTTPVersion number of the enclosed messages
eg 11 If not present the version can be
determined from the first line of the body
msgtype The message type  request or response If not
present the type can be determined from the first
line of the body
Encoding considerations HTTP messages enclosed by this type
are in binary format use of an appropriate
ContentTransferEncoding is required when
transmitted via Email
Security considerations none
Fielding et al
Standards Track
Page 164
RFC 2616
HTTP11
June 1999
192 Internet Media Type multipartbyteranges
When an HTTP 206 Partial Content response message includes the
content of multiple ranges a response to a request for multiple
nonoverlapping ranges these are transmitted as a multipart
messagebody The media type for this purpose is called
multipartbyteranges
The multipartbyteranges media type includes two or more parts each
with its own ContentType and ContentRange fields The required
boundary parameter specifies the boundary string used to separate
each bodypart
Media Type name
multipart
Media subtype name
byteranges
Required parameters
boundary
Optional parameters
none
Encoding considerations only 7bit 8bit or binary are
permitted
Security considerations none
For example
HTTP11 206 Partial Content
Date Wed 15 Nov 1995 062524 GMT
LastModified Wed 15 Nov 1995 045808 GMT
Contenttype multipartbyteranges boundaryTHIS_STRING_SEPARATES
THIS_STRING_SEPARATES
Contenttype applicationpdf
Contentrange bytes 5009998000
the first range
THIS_STRING_SEPARATES
Contenttype applicationpdf
Contentrange bytes 700079998000
the second range
THIS_STRING_SEPARATES
Notes
1 Additional CRLFs may precede the first boundary string in the
entity
Fielding et al
Standards Track
Page 165
RFC 2616
HTTP11
June 1999
2 Although RFC 2046 40 permits the boundary string to be
quoted some existing implementations handle a quoted boundary
string incorrectly
3 A number of browsers and servers were coded to an early draft
of the byteranges specification to use a media type of
multipartxbyteranges which is almost but not quite
compatible with the version documented in HTTP11
193 Tolerant Applications
Although this document specifies the requirements for the generation
of HTTP11 messages not all applications will be correct in their
implementation We therefore recommend that operational applications
be tolerant of deviations whenever those deviations can be
interpreted unambiguously
Clients SHOULD be tolerant in parsing the StatusLine and servers
tolerant when parsing the RequestLine In particular they SHOULD
accept any amount of SP or HT characters between fields even though
only a single SP is required
The line terminator for messageheader fields is the sequence CRLF
However we recommend that applications when parsing such headers
recognize a single LF as a line terminator and ignore the leading CR
The character set of an entitybody SHOULD be labeled as the lowest
common denominator of the character codes used within that body with
the exception that not labeling the entity is preferred over labeling
the entity with the labels USASCII or ISO88591 See section 371
and 341
Additional rules for requirements on parsing and encoding of dates
and other potential problems with date encodings include
 HTTP11 clients and caches SHOULD assume that an RFC850 date
which appears to be more than 50 years in the future is in fact
in the past this helps solve the year 2000 problem
 An HTTP11 implementation MAY internally represent a parsed
Expires date as earlier than the proper value but MUST NOT
internally represent a parsed Expires date as later than the
proper value
 All expirationrelated calculations MUST be done in GMT The
local time zone MUST NOT influence the calculation or comparison
of an age or expiration time
Fielding et al
Standards Track
Page 166
RFC 2616
HTTP11
June 1999
 If an HTTP header incorrectly carries a date value with a time
zone other than GMT it MUST be converted into GMT using the
most conservative possible conversion
194 Differences Between HTTP Entities and RFC 2045 Entities
HTTP11 uses many of the constructs defined for Internet Mail RFC
822 9 and the Multipurpose Internet Mail Extensions MIME 7 to
allow entities to be transmitted in an open variety of
representations and with extensible mechanisms However RFC 2045
discusses mail and HTTP has a few features that are different from
those described in RFC 2045 These differences were carefully chosen
to optimize performance over binary connections to allow greater
freedom in the use of new media types to make date comparisons
easier and to acknowledge the practice of some early HTTP servers
and clients
This appendix describes specific areas where HTTP differs from RFC
2045 Proxies and gateways to strict MIME environments SHOULD be
aware of these differences and provide the appropriate conversions
where necessary Proxies and gateways from MIME environments to HTTP
also need to be aware of the differences because some conversions
might be required
1941 MIMEVersion
HTTP is not a MIMEcompliant protocol However HTTP11 messages MAY
include a single MIMEVersion generalheader field to indicate what
version of the MIME protocol was used to construct the message Use
of the MIMEVersion header field indicates that the message is in
full compliance with the MIME protocol as defined in RFC 20457
Proxiesgateways are responsible for ensuring full compliance where
possible when exporting HTTP messages to strict MIME environments
MIMEVersion
 MIMEVersion  1DIGIT  1DIGIT
MIME version 10 is the default for use in HTTP11 However
HTTP11 message parsing and semantics are defined by this document
and not the MIME specification
1942 Conversion to Canonical Form
RFC 2045 7 requires that an Internet mail entity be converted to
canonical form prior to being transferred as described in section 4
of RFC 2049 48 Section 371 of this document describes the forms
allowed for subtypes of the text media type when transmitted over
HTTP RFC 2046 requires that content with a type of text represent
line breaks as CRLF and forbids the use of CR or LF outside of line
Fielding et al
Standards Track
Page 167
RFC 2616
HTTP11
June 1999
break sequences HTTP allows CRLF bare CR and bare LF to indicate a
line break within text content when a message is transmitted over
HTTP
Where it is possible a proxy or gateway from HTTP to a strict MIME
environment SHOULD translate all line breaks within the text media
types described in section 371 of this document to the RFC 2049
canonical form of CRLF Note however that this might be complicated
by the presence of a ContentEncoding and by the fact that HTTP
allows the use of some character sets which do not use octets 13 and
10 to represent CR and LF as is the case for some multibyte
character sets
Implementors should note that conversion will break any cryptographic
checksums applied to the original content unless the original content
is already in canonical form Therefore the canonical form is
recommended for any content that uses such checksums in HTTP
1943 Conversion of Date Formats
HTTP11 uses a restricted set of date formats section 331 to
simplify the process of date comparison Proxies and gateways from
other protocols SHOULD ensure that any Date header field present in a
message conforms to one of the HTTP11 formats and rewrite the date
if necessary
1944 Introduction of ContentEncoding
RFC 2045 does not include any concept equivalent to HTTP11s
ContentEncoding header field Since this acts as a modifier on the
media type proxies and gateways from HTTP to MIMEcompliant
protocols MUST either change the value of the ContentType header
field or decode the entitybody before forwarding the message Some
experimental applications of ContentType for Internet mail have used
a mediatype parameter of conversionscontentcoding to perform
a function equivalent to ContentEncoding However this parameter is
not part of RFC 2045
1945 No ContentTransferEncoding
HTTP does not use the ContentTransferEncoding CTE field of RFC
2045 Proxies and gateways from MIMEcompliant protocols to HTTP MUST
remove any nonidentity CTE quotedprintable or base64 encoding
prior to delivering the response message to an HTTP client
Proxies and gateways from HTTP to MIMEcompliant protocols are
responsible for ensuring that the message is in the correct format
and encoding for safe transport on that protocol where safe
Fielding et al
Standards Track
Page 168
RFC 2616
HTTP11
June 1999
transport is defined by the limitations of the protocol being used
Such a proxy or gateway SHOULD label the data with an appropriate
ContentTransferEncoding if doing so will improve the likelihood of
safe transport over the destination protocol
1946 Introduction of TransferEncoding
HTTP11 introduces the TransferEncoding header field section
1441 Proxiesgateways MUST remove any transfercoding prior to
forwarding a message via a MIMEcompliant protocol
A process for decoding the chunked transfercoding section 36
can be represented in pseudocode as
length  0
read chunksize chunkextension if any and CRLF
while chunksize  0
read chunkdata and CRLF
append chunkdata to entitybody
length  length + chunksize
read chunksize and CRLF

read entityheader
while entityheader not empty
append entityheader to existing header fields
read entityheader

ContentLength  length
Remove chunked from TransferEncoding
1947 MHTML and Line Length Limitations
HTTP implementations which share code with MHTML 45 implementations
need to be aware of MIME line length limitations Since HTTP does not
have this limitation HTTP does not fold long lines MHTML messages
being transported by HTTP follow all conventions of MHTML including
line length limitations and folding canonicalization etc since
HTTP transports all messagebodies as payload see section 372 and
does not interpret the content or any MIME header lines that might be
contained therein
195 Additional Features
RFC 1945 and RFC 2068 document protocol elements used by some
existing HTTP implementations but not consistently and correctly
across most HTTP11 applications Implementors are advised to be
aware of these features but cannot rely upon their presence in or
interoperability with other HTTP11 applications Some of these
Fielding et al
Standards Track
Page 169
RFC 2616
HTTP11
June 1999
describe proposed experimental features and some describe features
that experimental deployment found lacking that are now addressed in
the base HTTP11 specification
A number of other headers such as ContentDisposition and Title
from SMTP and MIME are also often implemented see RFC 2076 37
1951 ContentDisposition
The ContentDisposition responseheader field has been proposed as a
means for the origin server to suggest a default filename if the user
requests that the content is saved to a file This usage is derived
from the definition of ContentDisposition in RFC 1806 35
contentdisposition  ContentDisposition
dispositiontype   dispositionparm
dispositiontype  attachment  dispextensiontoken
dispositionparm  filenameparm  dispextensionparm
filenameparm  filename  quotedstring
dispextensiontoken  token
dispextensionparm  token   token  quotedstring
An example is
ContentDisposition attachment filenamefnameext
The receiving user agent SHOULD NOT respect any directory path
information present in the filenameparm parameter which is the only
parameter believed to apply to HTTP implementations at this time The
filename SHOULD be treated as a terminal component only
If this header is used in a response with the applicationoctet
stream contenttype the implied suggestion is that the user agent
should not display the response but directly enter a save response
as dialog
See section 155 for ContentDisposition security issues
196 Compatibility with Previous Versions
It is beyond the scope of a protocol specification to mandate
compliance with previous versions HTTP11 was deliberately
designed however to make supporting previous versions easy It is
worth noting that at the time of composing this specification
1996 we would expect commercial HTTP11 servers to
 recognize the format of the RequestLine for HTTP09 10 and
11 requests
Fielding et al
Standards Track
Page 170
RFC 2616
HTTP11
June 1999
 understand any valid request in the format of HTTP09 10 or
11
 respond appropriately with a message in the same major version
used by the client
And we would expect HTTP11 clients to
 recognize the format of the StatusLine for HTTP10 and 11
responses
 understand any valid response in the format of HTTP09 10 or
11
For most implementations of HTTP10 each connection is established
by the client prior to the request and closed by the server after
sending the response Some implementations implement the KeepAlive
version of persistent connections described in section 1971 of RFC
2068 33
1961 Changes from HTTP10
This section summarizes major differences between versions HTTP10
and HTTP11
19611 Changes to Simplify Multihomed Web Servers and Conserve IP
Addresses
The requirements that clients and servers support the Host request
header report an error if the Host requestheader section 1423 is
missing from an HTTP11 request and accept absolute URIs section
512 are among the most important changes defined by this
specification
Older HTTP10 clients assumed a onetoone relationship of IP
addresses and servers there was no other established mechanism for
distinguishing the intended server of a request than the IP address
to which that request was directed The changes outlined above will
allow the Internet once older HTTP clients are no longer common to
support multiple Web sites from a single IP address greatly
simplifying large operational Web servers where allocation of many
IP addresses to a single host has created serious problems The
Internet will also be able to recover the IP addresses that have been
allocated for the sole purpose of allowing specialpurpose domain
names to be used in rootlevel HTTP URLs Given the rate of growth of
the Web and the number of servers already deployed it is extremely
Fielding et al
Standards Track
Page 171
RFC 2616
HTTP11
June 1999
important that all implementations of HTTP including updates to
existing HTTP10 applications correctly implement these
requirements
 Both clients and servers MUST support the Host requestheader
 A client that sends an HTTP11 request MUST send a Host header
 Servers MUST report a 400 Bad Request error if an HTTP11
request does not include a Host requestheader
 Servers MUST accept absolute URIs
1962 Compatibility with HTTP10 Persistent Connections
Some clients and servers might wish to be compatible with some
previous implementations of persistent connections in HTTP10
clients and servers Persistent connections in HTTP10 are
explicitly negotiated as they are not the default behavior HTTP10
experimental implementations of persistent connections are faulty
and the new facilities in HTTP11 are designed to rectify these
problems The problem was that some existing 10 clients may be
sending KeepAlive to a proxy server that doesnt understand
Connection which would then erroneously forward it to the next
inbound server which would establish the KeepAlive connection and
result in a hung HTTP10 proxy waiting for the close on the
response The result is that HTTP10 clients must be prevented from
using KeepAlive when talking to proxies
However talking to proxies is the most important use of persistent
connections so that prohibition is clearly unacceptable Therefore
we need some other mechanism for indicating a persistent connection
is desired which is safe to use even when talking to an old proxy
that ignores Connection Persistent connections are the default for
HTTP11 messages we introduce a new keyword Connection close for
declaring nonpersistence See section 1410
The original HTTP10 form of persistent connections the Connection
KeepAlive and KeepAlive header is documented in RFC 2068 33
1963 Changes from RFC 2068
This specification has been carefully audited to correct and
disambiguate key word usage RFC 2068 had many problems in respect to
the conventions laid out in RFC 2119 34
Clarified which error code should be used for inbound server failures
eg DNS failures Section 1055
Fielding et al
Standards Track
Page 172
RFC 2616
HTTP11
June 1999
CREATE had a race that required an Etag be sent when a resource is
first created Section 1022
ContentBase was deleted from the specification it was not
implemented widely and there is no simple safe way to introduce it
without a robust extension mechanism In addition it is used in a
similar but not identical fashion in MHTML 45
Transfercoding and message lengths all interact in ways that
required fixing exactly when chunked encoding is used to allow for
transfer encoding that may not be self delimiting it was important
to straighten out exactly how message lengths are computed Sections
36 44 722 1352 1413 1416
A contentcoding of identity was introduced to solve problems
discovered in caching section 35
Quality Values of zero should indicate that I dont want something
to allow clients to refuse a representation Section 39
The use and interpretation of HTTP version numbers has been clarified
by RFC 2145 Require proxies to upgrade requests to highest protocol
version they support to deal with problems discovered in HTTP10
implementations Section 31
Charset wildcarding is introduced to avoid explosion of character set
names in accept headers Section 142
A case was missed in the CacheControl model of HTTP11 smaxage
was introduced to add this missing case Sections 134 148 149
1493
The CacheControl maxage directive was not properly defined for
responses Section 1493
There are situations where a server especially a proxy does not
know the full length of a response but is capable of serving a
byterange request We therefore need a mechanism to allow byteranges
with a contentrange not indicating the full length of the message
Section 1416
Range request responses would become very verbose if all metadata
were always returned by allowing the server to only send needed
headers in a 206 response this problem can be avoided Section
1027 1353 and 1427
Fielding et al
Standards Track
Page 173
RFC 2616
HTTP11
June 1999
Fix problem with unsatisfiable range requests there are two cases
syntactic problems and range doesnt exist in the document The 416
status code was needed to resolve this ambiguity needed to indicate
an error for a byte range request that falls outside of the actual
contents of a document Section 10417 1416
Rewrite of message transmission requirements to make it much harder
for implementors to get it wrong as the consequences of errors here
can have significant impact on the Internet and to deal with the
following problems
1 Changing HTTP11 or later to HTTP11 in contexts where
this was incorrectly placing a requirement on the behavior of
an implementation of a future version of HTTP1x
2 Made it clear that useragents should retry requests not
clients in general
3 Converted requirements for clients to ignore unexpected 100
Continue responses and for proxies to forward 100 responses
into a general requirement for 1xx responses
4 Modified some TCPspecific language to make it clearer that
nonTCP transports are possible for HTTP
5 Require that the origin server MUST NOT wait for the request
body before it sends a required 100 Continue response
6 Allow rather than require a server to omit 100 Continue if
it has already seen some of the request body
7 Allow servers to defend against denialofservice attacks and
broken clients
This change adds the Expect header and 417 status code The message
transmission requirements fixes are in sections 82 10418
8122 1311 and 1420
Proxies should be able to add ContentLength when appropriate
Section 1352
Clean up confusion between 403 and 404 responses Section 1044
1045 and 10411
Warnings could be cached incorrectly or not updated appropriately
Section 1312 1324 1352 1353 1493 and 1446 Warning
also needed to be a general header as PUT or other methods may have
need for it in requests
Fielding et al
Standards Track
Page 174
RFC 2616
HTTP11
June 1999
Transfercoding had significant problems particularly with
interactions with chunked encoding The solution is that transfer
codings become as full fledged as contentcodings This involves
adding an IANA registry for transfercodings separate from content
codings a new header field TE and enabling trailer headers in the
future Transfer encoding is a major performance benefit so it was
worth fixing 39 TE also solves another obscure downward
interoperability problem that could have occurred due to interactions
between authentication trailers chunked encoding and HTTP10
clientsSection 36 361 and 1439
The PATCH LINK UNLINK methods were defined but not commonly
implemented in previous versions of this specification See RFC 2068
33
The Alternates ContentVersion DerivedFrom Link URI Public and
ContentBase header fields were defined in previous versions of this
specification but not commonly implemented See RFC 2068 33
20 Index
Please see the PostScript version of this RFC for the INDEX
Fielding et al
Standards Track
Page 175
RFC 2616
HTTP11
June 1999
21
Full Copyright Statement
Copyright C The Internet Society 1999
All Rights Reserved
This document and translations of it may be copied and furnished to
others and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared copied published
and distributed in whole or in part without restriction of any
kind provided that the above copyright notice and this paragraph are
included on all such copies and derivative works
However this
document itself may not be modified in any way such as by removing
the copyright notice or references to the Internet Society or other
Internet organizations except as needed for the purpose of
developing Internet standards in which case the procedures for
copyrights defined in the Internet Standards process must be
followed or as required to translate it into languages other than
English
The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns
This document and the information contained herein is provided on an
AS IS basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
TASK FORCE DISCLAIMS ALL WARRANTIES EXPRESS OR IMPLIED INCLUDING
BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
Acknowledgement
Funding for the RFC Editor function is currently provided by the
Internet Society
Fielding et al
Standards Track
Page 176
Html markup produced by rfcmarkup 1124 available from
httpstoolsietforgtoolsrfcmarkup
